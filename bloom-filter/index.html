<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="Programio" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><title>Bloom filter - Programio</title><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro"><link rel="stylesheet" href="/css/main.css" type="text/css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"> <a href="/">Programio</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Domů</a></li><li class="head-nav__item"><a href="/archives" class="head-nav__link">Archiv</a></li><li class="head-nav__item"><a href="http://www.havrlant.cz/" class="head-nav__link">O autorovi</a></li><li class="head-nav__item"><a href="/rss.xml" class="head-nav__link">RSS</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2016-09-05T17:20:48.000Z" class="post__time">5. 9. 2016</time><h1 class="post__title"><a href="/bloom-filter/">Bloom filter</a></h1></header><div class="post__main echo"><p>Bloom filter je pravděpodobnostní struktura, která nám umožňuje s jistou mírou pravděpodobnosti říci, zda se nějaký prvek <code>x</code> nachází v množině <code>M</code>.</p>
<p>V našem systému například potřebujeme měřit, kolikrát uživatelé klikli na reklamní banner. Po každém kliknutí k nám přijde HTTP GET požadavek informující nás o tom, že uživatel XYZ klikl na reklamu 123. Občas se stane, že uživatel omylem myší dvojklikne a nám tak přijdou dva požadavky. My bychom rádi tyto požadavky odfiltrovali a měli je v databázi zaznamenané jako jeden klik.</p>
<p>Potřebujeme proto aplikaci, která bude číst kanál se zprávami o klicích a bude odfiltrovávat duplikace. Jak bychom to udělali? Každá taková zpráva má nějaké ID, nemusíme proto porovnávat celou zprávu, stačí nám zjistit, jestli jsme už někdy nezpracovali zprávu se stejným ID. Jednoduchý kód v JavaScriptu, který by odstraňoval duplikace ze streamu (zde pro jednoduchost z pole) zpráv by mohl vypadat takto:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> messages = [&#123;id: <span class="string">"123"</span>&#125;, &#123;id:<span class="string">"456"</span>&#125;, &#123;id:<span class="string">"123"</span>&#125;, &#123;id: <span class="string">"789"</span>&#125;]</span><br><span class="line"><span class="keyword">var</span> processedIds = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">messages.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!processedIds[message.id]) &#123;</span><br><span class="line">        processedIds[message.id] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vytiskne: &#123; id: "123" &#125; &#123; id: "456" &#125; &#123; id: "789" &#125;</span></span><br></pre></td></tr></table></figure>
<p>Toto řešení bude stačit do doby, než nám dojde paměť – a ta jednou dojde, protože množina <code>processedIds</code> bude časem jen a pouze růst. Můžeme samozřejmě doprogramovat nějakou expiraci dat – můžeme vždy odstranit zprávy starší než jedna hodina nebo něco podobného.</p>
<p>Horší je, když ani to nestačí. Co když potřebujeme mít v množině <code>processedIds</code> data za alespoň jeden den a procházíme třeba deset tisíc zpráv za sekundu? V nejhorším případě potřebujeme uložit až <a href="https://goo.gl/iOGIvz" target="_blank" rel="external">864 000 000</a> Idéček. Používáme-li <a href="https://github.com/broofa/node-uuid" target="_blank" rel="external">uuid v4</a>, má každé ID délku 36, což znamená, že za den potřebujeme uložit nejméně <a href="https://goo.gl/Bs6bR4" target="_blank" rel="external">32 GB</a>. To je trochu hodně. Nešla by ta paměťová náročnost snížit?</p>
<h2 id="bloom-filter">Bloom filter</h2>
<p>Místo toho, abychom si ukládali celé ID, můžeme si ukládat jen jeho hash. Můžeme použít klasickou <a href="https://github.com/perezd/node-murmurhash" target="_blank" rel="external">murmurhash</a>, která vrací pro každý string 32bitové celé číslo, navíc má dobré rozdělení. Dále použijeme fígl s bitovým vektorem. To je pole, do kterého budeme ukládat jen nuly a jedničky. Máme-li <code>n</code>-bitovou hashovací funkci, potřebujeme vektor o velikosti 2<sup>n</sup>, abychom byli schopni ve vektoru adresovat všechny možné výstupy hashovací funkce. Idea je, že na začátku obsahuje vektor samé nuly. Pokud nám pak hashovací funkce pro vstup <code>&quot;123&quot;</code> vrátí číslo 47, jednoduše do vektoru na index 47 vložíme jedničku. Tím si označíme, že hash o hodnotě 47 jsme už viděli.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">var</span> numberOfValues = <span class="built_in">Math</span>.pow(<span class="number">2</span>, n);</span><br><span class="line"><span class="keyword">var</span> messages = [&#123;id: <span class="string">"123"</span>&#125;, &#123;id:<span class="string">"456"</span>&#125;, &#123;id:<span class="string">"123"</span>&#125;, &#123;id: <span class="string">"789"</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> bitVector = <span class="keyword">new</span> <span class="built_in">Array</span>(numberOfValues);</span><br><span class="line"></span><br><span class="line">messages.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hashedId = murmurhash.v2(message.id) % numberOfValues;</span><br><span class="line">    <span class="keyword">if</span> (!bitVector[hashedId]) &#123;</span><br><span class="line">        bitVector[hashedId] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vytiskne: &#123; id: "123" &#125; &#123; id: "456" &#125; &#123; id: "789" &#125;</span></span><br></pre></td></tr></table></figure>
<p>Tím kódem <code>% numberOfValues</code> jsme jen ořezali murmurhash tak, aby z ní byla <code>n</code>-bitová hashovací funkce, nic víc. A toto je Bloom filter. I když taková hodně degenerovaná verze. Problémem tohoto přístupu jsou pochopitelně kolize, které nutně nastanou. Různé vstupní hodnoty mohou mít stejný výstupní hash.</p>
<p>Abychom proto snížili pravděpodobnost, že dojde ke kolizi, nepoužijeme pouze jednu hashovací funkci, ale použijeme jich více. Více hashovacích funkcí můžeme vytvořit například tím, že k vstupní hodnotě přidáme nějakou sůl. Jednoduchá funkce, která by vytvářela různé <code>n</code>-bitové hashovací funkce by mohla vypadat takto:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> murmurhash = <span class="built_in">require</span>(<span class="string">"murmurhash"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNBitHashFunction</span>(<span class="params">n, salt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> upperBound = <span class="built_in">Math</span>.pow(<span class="number">2</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">inputString</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> murmurhash.v2(inputString + salt) % upperBound;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> firstHashFunction = createNBitHashFunction(<span class="number">8</span>, <span class="string">"nejakaSul"</span>);</span><br><span class="line"><span class="keyword">var</span> secondHashFunction = createNBitHashFunction(<span class="number">8</span>, <span class="string">"nejakaJinaSul"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstHashFunction(<span class="string">"123"</span>)); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">console</span>.log(secondHashFunction(<span class="string">"123"</span>)); <span class="comment">// 174</span></span><br></pre></td></tr></table></figure>
<p>Tyto dvě hashovací funkce bychom využili tak, že bychom vstupní hodnut zahashovali oběma funkcemi a na oba vygenerované indexy bychom uložili jedničku, tj. pro vstup <code>&quot;123&quot;</code> bychom uložili do bitové vektoru jedničky na indexy 42 i na 174.</p>
<p>Při následném dotazu na to, zda jsme už string <code>&quot;123&quot;</code> viděli, ho opět zahashujeme stejnými funkcemi a opět nám vyjdou indexy 42 a 174. Podíváme se na hodnoty v bitovém vektoru a pokud je na jednom z indexů nula, string jsme si do množiny neuložili. Pokud tam budou dvě jedničky, tento string jsme <em>asi</em> do množiny uložili. Samozřejmě může nastat případ, že nějaký úplně jiný string se zahashoval na dvojici čísel 42 a 174, tj. nastala kolize. To se s Bloom filter může stát.</p>
<h3 id="algoritmus-bloom-filteru">Algoritmus Bloom filteru</h3>
<p>Algoritmus Bloom filteru bychom proto mohli napsat takto:</p>
<ul>
<li><strong>Inicializace:</strong>
<ol style="list-style-type: decimal">
<li>Zvolíme počet hashovacích funkcí a jejich velikost</li>
<li>Inicializujeme bitový vektor nulami, a to tak, abychom v něm mohli adresovat všechny hodnoty hashovací funkce.</li>
</ol></li>
<li><strong>Přidání prvku do pole:</strong>
<ol style="list-style-type: decimal">
<li>Vstupní hodnotu zahashujeme všemi hashovacími funkcemi a uložíme si do bitového vektoru na příslušná místa jedničku.</li>
</ol></li>
<li><strong>Kontrola existence prvku v množině:</strong>
<ol style="list-style-type: decimal">
<li>Hledanou hodnotu zahashujeme všemi hashovacími funkcemi</li>
<li>Pokud pro alespoň jeden výsledek hashovací funkce platí, že na daném indexu bitového pole je nula, hledaný prvek v množině není.</li>
<li>V opačném případě tam <em>asi</em> je.</li>
</ol></li>
</ul>
<h3 id="implementace-v-javascriptu">Implementace v JavaScriptu</h3>
<p>Třídu reprezentující Bloom filter můžeme napsat takto:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BloomFilter</span>(<span class="params">numberOfHashFunctions, numberOfBits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bitVector = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">Math</span>.pow(<span class="number">2</span>, numberOfBits));</span><br><span class="line">    <span class="keyword">this</span>.hashFunctions = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numberOfHashFunctions; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hashFunctions.push(createNBitHashFunction(numberOfBits, i.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BloomFilter.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> checksum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.hashFunctions.length; i++) &#123;</span><br><span class="line">        checksum = <span class="keyword">this</span>.hashFunctions[i](item);</span><br><span class="line">        <span class="keyword">this</span>.bitVector[checksum] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BloomFilter.prototype.contains = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> checksum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.hashFunctions.length; i++) &#123;</span><br><span class="line">        checksum = <span class="keyword">this</span>.hashFunctions[i](item);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.bitVector[checksum]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Metoda <code>add</code> přidává prvek do Bloom filteru: spočítá hash všemi hashovacími funkce a na odpovídající index uloží <code>true</code>.</li>
<li>Metoda <code>contains</code> pak zjišťuje, jestli jedaný prvek obsažen v Bloom filteru.</li>
</ul>
<p>Bloom filter můžeme použít snadno:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bloomFilter = <span class="keyword">new</span> BloomFilter(<span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> messages = [&#123;id: <span class="string">"123"</span>&#125;, &#123;id:<span class="string">"456"</span>&#125;, &#123;id:<span class="string">"123"</span>&#125;, &#123;id: <span class="string">"789"</span>&#125;];</span><br><span class="line"></span><br><span class="line">messages.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!bloomFilter.contains(message.id)) &#123;</span><br><span class="line">        bloomFilter.add(message.id);</span><br><span class="line">        <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vytiskne: &#123; id: "123" &#125; &#123; id: "456" &#125; &#123; id: "789" &#125;</span></span><br></pre></td></tr></table></figure>
<p>A to je celá magie základního Bloom Filteru.</p>
<h2 id="vlastnosti-bloom-filteru">Vlastnosti Bloom filteru</h2>
<ul>
<li>Nejzásadnější vlastností je, že paměťová náročnost Bloom filteru je velmi nízká, o několik řádů nižší, než kdybychom ukládali všechna IDéčka. Potřebujeme uložit pouze bitový vektor, nic více.</li>
<li>Pokud metoda <code>contains</code> odpoví, že daný prvek v Bloom Filteru není, znamená, že jsme do něj daný prvek opravdu nikdy nevložili.</li>
<li>Pokud metoda <code>contains</code> odpoví, že daný prvek v Bloom Filteru je přítomen, nemusí to nutně znamenat, že jsme do něj daný prvek opravdu uložili – mohla totiž nastat kolize hashovacích funkcí.</li>
<li>Obecně platí, že chceme-li snížit pravděpodobnost nesprávné odpovědi, musíme zvýšit počet hashovacích funkcí nebo zvýšit jejich velikost (myšleno velikost výstupní hodnoty).</li>
<li>Čím více hashovacích funkcí použijeme, tím pomalejší Bloom Filter bude.</li>
<li>Čím větší hashovací funkce použijeme, tím více místa bude Bloom Filter zabírat.</li>
<li>Pokud jednou nějaký prvek do Bloom Filteru vložíme, už ho není možné odstranit.</li>
<li>Bloom filter nikdy “nenaplníme”, uložíme do něj nekonečně hodnot. Jenom nám bude neustále růst pravděpodobnost kolize…</li>
</ul>
<p>Existují varianty Bloom filteru, které například umožňují odstraňovat jednou přidané prvky. O těch si povíme příště.</p>
<h2 id="příklady-použití">Příklady použití</h2>
<p>Bloom filter je v praxi hojně používaný, viz <a href="https://en.wikipedia.org/wiki/Bloom_filter#Examples" target="_blank" rel="external">příklady na Wiki</a>.</p>
<!-- p="A jestli vás článek opravdu zaujal, "--><!--  a(href="http://www.ibillboard.com/cs/spolecnost/spolecnost/kariera/202-vyvojar-nodejs-javascript")="tak pojďte pracovat k nám do firmy!"--><!--  =" Podobných problémů řešíme mraky." -->
<div class="relatedBox"><div class="relatedArticlesBox"><h2 id="relatedArticles">Související články:</h2><ol><li><a href="/linear-counting/">Linear Counting: Jak odhadnout počet unikátních hodnot</a></li><li><a href="/min-value/">Min Value: Jak odhadnout počet unikátních hodnot</a></li><li><a href="/loglog/">LogLog: Jak odhadnout počet unikátních hodnot</a></li><li><a href="/hyperloglog/">HyperLogLog: Jak odhadnout počet unikátních hodnot</a></li><li><a href="/sjednoceni-hyperloglogu/">Sjednocení Hyperloglogu</a></li></ol></div></div><div class="articleTags"><strong><a href="/tags/algoritmy">#algoritmy</a></strong>, <strong><a href="/tags/bloom filter">#bloom filter</a></strong></div></div></article><div style="text-align: right"><div class="fb-like" data-layout="button_count" data-action="like" data-show-faces="true" data-share="true" style="margin-top: 10px; height: 30px"></div></div><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/algoritmy/" class="post__tag__link">algoritmy</a></li><li class="post__tag__item"><a href="/tags/bloom-filter/" class="post__tag__link">bloom filter</a></li></ul><a href="/bloom-filter/#disqus_thread" class="post__foot-link u-fr">Komentáře</a></footer></main><footer class="foot"><div class="foot-copy u-fl"><a href="/">Programio</a> píše <a href="http://www.havrlant.cz/">Lukáš Havrlant</a></div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><a title="Next" href="/chyby/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],
j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})
(document,"script","programio","embed");
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-1559810-13');ga('send','pageview');
</script><div id="fb-root"></div><script>(function(d, s, id) {
var js, fjs = d.getElementsByTagName(s)[0];
if (d.getElementById(id)) return;
js = d.createElement(s); js.id = id;
js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&appId=166268190106534&version=v2.0";
fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script></body></html>