<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="Programio" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><title>Jak zpracováváme velké množství dat: Lambda Architecture - Programio</title><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro"><link rel="stylesheet" href="/css/main.css" type="text/css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"> <a href="/">Programio</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Domů</a></li><li class="head-nav__item"><a href="/archives" class="head-nav__link">Archiv</a></li><li class="head-nav__item"><a href="http://www.havrlant.cz/" class="head-nav__link">O autorovi</a></li><li class="head-nav__item"><a href="/rss.xml" class="head-nav__link">RSS</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2015-03-10T19:34:45.000Z" class="post__time">10. 3. 2015</time><h1 class="post__title"><a href="/lambda-architecture/">Jak zpracováváme velké množství dat: Lambda Architecture</a></h1></header><div class="post__main echo"><p>Rozhodl jsem se napsat sérii článků, ve kterých popíši, jaké postupy a jaký software používáme k tomu, abychom zvládali zpracovávat provoz v řádu desítek tisíc zpráv za sekundu. Pracuji ve firmě <a href="http://www.ibillboard.com/cs/" target="_blank" rel="external">Internet Billboard</a>, kterou nejspíš znáte, aniž o tom víte. Všimli jste si někdy reklam na iDnesu, denik.cz, ČSFD…? Tak to, že se tam ty reklamy objevily, je naše práce; respektive práce mých předků. Jednoduše řečeno, dodáváme a vyvíjíme technologie pro zobrazování internetové reklamy. V podstatě vyvíjíme něco podobného jako je Google AdWords/AdSense. </p>
<p>Abyste byli v obraze, kolik dat musíme přibližně zpracovávat: Za rok 2014 jsme vyservírovali <a href="http://www.ibillboard.com/2015/cz" target="_blank" rel="external">243 392 081 935 zobrazení reklamních bannerů</a>, což je v průměru 7700 zobrazení za sekundu; ve špičkách mnohem více. Ne že bychom měli provoz jako Facebook, ale na jednom MySQL stroji to taky neutáhneme. Teď se snažíme vytvořit novou verzi statistik, které toho budou umět zásadně více než ty předchozí, budou zpracovávat daleko více dat, budou dobře škálovatelné a vůbec se budou motat kolem termínů jako <a href="http://blog.confluent.io/2015/01/29/making-sense-of-stream-processing/" target="_blank" rel="external">stream processing, event sourcing, reactive, cep, …</a></p>
<h2 id="Real-time_bidding">Real-time bidding</h2><p>Pojďme se nejdříve podívat na to, jaký konkrétní problém aktuálně řešíme. Současný trend v internetové reklamě je Real-time bidding (RTB), což je jakási real time aukce reklam. Co se všechno stane předtím, než vám AdBlock zablokuje zobrazení reklamy v prohlížeči? </p>
<ol>
<li>Přijdete například na ČSFD. Stránka pošle na naše servery požadavek, ve kterém žádá o reklamu, kterou má uživateli zobrazit. </li>
<li>My požadavek přijmeme a spustíme aukci. Problém je, že reklamy, které se účastní aukce, nemáme na našich serverech, ale jsou na serverech někoho úplně jiného. Těmto vzdálených serverům říkáme <strong>D</strong>emand <strong>S</strong>ide <strong>P</strong>latform. Všem DSPéčkům pošleme HTTP požadavek typu <em>“Hele, mám volnou reklamní pozici 250x250 na ČSFD. Nechcete tam zobrazit nějaký svůj banner?”</em> </li>
<li>Každé DSPéčko nějak odpoví. Buď <em>“Nechci.”</em>, nebo <em>“Chci a nabízím za zobrazení pět korun. Tady máte kód reklamy.”</em></li>
<li>My si z těchto došlých odpovědí vybereme nejlepší nabídku; typicky takovou reklamu, za kterou DSPéčko nabízí nejvíce peněz. </li>
<li>Pošleme odpověď zpět na ČSFD, kde se Javascriptem vloží reklama do stránky. </li>
</ol>
<p><img src="/images/kafka/rtb2.svg" alt=""></p>
<h2 id="Nové_výzvy">Nové výzvy</h2><p>Současné statistiky fungují dobře a obsahují data nezbytná k našemu podnikání, ale trpí především tím, že nejsou moc dobře horizontálně škálovatelné. Vrátíme-li se k RTB, tak bychom například rádi měli zaznamenané <strong>všechny požadavky a odpovědi</strong>, které během aukce nastanou. To se dříve nedělalo, protože to nebylo potřeba, ale čas ukázal, že by se tato data – a hlavně jejich analýza! – mohla hodit.</p>
<p>Celý seriál se bude točit o tom, jak ukládáme a zpracováváme právě požadavky poslané DSPéčkům a odpovědi od nich. Takových dat <em>nebude málo</em>, přičemž s časem počet těchto zpráv poroste, protože roste provoz v celém RTB. Tyto zprávy musí ze serverů nějakým způsobem odtéct a musí dotéct někam, kde ty zprávy budeme uchovávat a analyzovat. </p>
<p>Jaké bylo hlavní zadání nových statistik? </p>
<ul>
<li><p>Musí být <strong>horizontálně škálovatelné</strong>. Pokud by za námi ráno přišel Jimmy Wales, že by rád zobrazoval naši reklamu na Wikipedii, my dopoledne nakoupíme nové servery, odpoledne tam nainstalujeme a nakonfigurujeme potřebný software a večer musíme být schopni servírovat na Wikipedii reklamu. </p>
</li>
<li><p>Musí být <strong>realtime</strong>. Současné statistiky jsou zpožděné přibližně o jednu hodinu. Pokud si uživatel teď vygeneruje report, nebudou v něm obsaženy imprese a kliky, které se staly před třemi minutami. Nyní chceme, aby tato prodleva prakticky neexistovala – aby nebyla větší než pár sekund. A co třeba grafy na dashboardu, které ukazují aktuální data a ještě se automaticky aktualizují třeba pomocí Socket.io? Pokud bychom se rozhodli, že takovou funkcionalitu chceme, musíme být schopni ji v pohodě naprogramovat a obsloužit. </p>
</li>
<li><p>Musí být <strong>výpadkuvzdorné</strong>. Ideálně bychom chtěli, aby byla každá součást replikovaná a výpadek jedné ze služeb by tak neměl žádný vliv na výsledné statistiky. Ruční údržba připadá v úvahu, až když toho popadá opravdu hodně. Přitom bychom měli být schopni znovu zpracovat i stará data, pokud se kvůli výpadkům nezpracovala správně. </p>
</li>
</ul>
<h2 id="Architektura_nových_statistik">Architektura nových statistik</h2><p>To, co se snažíme vybudovat, má dokonce i svůj buzzword: <a href="http://lambda-architecture.net" target="_blank" rel="external">Lambda Architecture</a> (viz <a href="http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html" target="_blank" rel="external">How to beat the CAP theorem</a>). Principem je, že máme realtime větev, kterou zpracováváme aktuální data. Tato větev zajišťuje, že každá událost, která nastane, bude za pár sekund dotazovatelná. Nicméně tato větev je obecně nespolehlivá, protože přese všechny replikace se může stát, že se něco pokazí, něco se někam nepřesune jak má, nestihnou se zpracovat nějaké události, které dorazily později, než se očekávalo a podobně.</p>
<p>Proto vedle realtime větve máme ještě batch větvi. Ta se spouští jednou za čas, dejme tomu jednou za den, a přepočítává stará data tak, aby byly výsledky přesné. Takže ve dvě ráno můžeme spustit nějaký batch job, který přepočítá data za včerejšek a ta data, která včera zpracovala realtime větev zahodíme. </p>
<p>Zatímco realtime větev musí být optimalizovaná tak, aby průchozí data zpracovávala <em>rychle</em>, batch větev je optimalizována tak, aby zpracovávala data <em>přesně</em>. </p>
<h2 id="Kappa_architecture">Kappa architecture</h2><p>Batch větev ale ještě nemáme úplně pořešenou. Hlavní problém Lambda architektury totiž je, že se jen těžko vyhneme zdvojenému kódu. Musíme mít nějaký kód, který bude zpracovávat data v realtime větvi a pak musíme mít nějaký kód, který bude zpracovávat data v batch větvi – tato část se píše například jako MapReduce job v Hadoopu. Výstupem by měla být stejná data a je otázkou, jak moc lze sdílet zdrojový kód v obou větvích. Psát stejný kód dvakrát pro dva různé systémy samozřejmě moc nechceme…</p>
<p>Proto ještě uvažujeme o jiné architektuře, ta dostala jména <a href="http://radar.oreilly.com/2014/07/questioning-the-lambda-architecture.html" target="_blank" rel="external">Kappa architecture</a>, která předpokládá, že ohneme realtime větev tak, aby šla použít i na batch zpracování o den později. Pak bychom měli jen jeden dev-stack a batch větev by byla klasická “realtime větev”, pouze s jiným nastavením.</p>
<h2 id="Jaký_software_používáme">Jaký software používáme</h2><p>K tomu všemu používáme tohle: </p>
<ul>
<li><p>Vstupním bodem všech našich nových aplikací jsou servery psané v Node.JS (starý server byl psán v Céčku), které běží v nějakém <a href="https://github.com/ql-io/cluster2" target="_blank" rel="external">Clusteru</a>. Když jeden server přestane stačit, přidá se jednoduše další a na Nginxu se rozdělí provoz. </p>
</li>
<li><p>Většina dat, se kterými pracujeme, nakonec skončí v <a href="http://hadoop.apache.org/" target="_blank" rel="external">Hadoopu</a>, což je distribuovaný file system, který má zároveň API pro psaní jobů nad daty v něm uloženými (MapReduce). My vlastně v současnosti Hadoop využíváme jen jako externí závislost ostatních programů, které do něj ukládají svá data. V budoucnu nejspíš sepíšeme zapojíme i nějaký ten Spark nebo Hive a zkusíme analyzovat data přímo v Hadoopu. Ale zatím to neděláme. </p>
</li>
<li><p>Potřebujeme-li data dostat z jednoho serveru na druhý, používáme k tomu <a href="http://kafka.apache.org/" target="_blank" rel="external">Kafku</a>. Kafka (opravdu je pojmenována podle spisovatele) je distribuovaný systém pro posílání zpráv, který vyvinul LinkedIn. Na jedné straně do Kafky všechny naše Node.JS servery posílají data (obvykle nějaký JSON) a na straně druhé konzumenti tato data zase čtou a něco s nimi dělají. Kafka je krásně distribuovaná, takže můžeme snadno nastavit, že se všechna data mají replikovat na x fyzicky odlišných serverů a podobně. </p>
</li>
<li><p>Data, která prochází Kafkou, potřebujeme nějak dále upravovat – k tomu používáme další open source projekt od LinkedInu, a to <a href="http://samza.incubator.apache.org" target="_blank" rel="external">Samzu</a>. Samza umí číst zprávy z Kafky, provést nějaký námi napsaný kód (odstranit duplikované zprávy, zvalidovat data, přidat ke zprávě nějaká data z databáze…), a zase data uložit zpět do Kafky nebo je poslat přímo do databáze. </p>
</li>
</ul>
<ul>
<li><p>Data z Kafky do Hadoopu dostáváme pomocí aplikace <a href="https://github.com/linkedin/camus" target="_blank" rel="external">Camus</a>. Je to MapReduce job, je to open source … a vyvíjí to LinkedIn. Jo a nečte se to [kejmus], hehe, ale [kamy], protože Camus byl <a href="http://en.wikipedia.org/wiki/Albert_Camus" target="_blank" rel="external">francouzský spisovatel</a>. </p>
</li>
<li><p>Srdcem našich statistik je <a href="http://druid.io" target="_blank" rel="external">Druid</a> – distribuovaná (jak jinak), vysoce škálovatelná, databáze, která umožňuje zpracovávat velké množství dat a okamžitě tato data dávat k dispozici pro dotazování. Druid je optimalizovaný jak pro zpracování realtime dat, tak i pro ukládání historických (třeba pět let starých) dat. Dále obsahuje podporu pro aproximační algoritmy jako je <a href="/hyperloglog">HyperLogLog</a> pro odhadování počtu unikátních hodnot ve sloupci nebo pro aproximaci histogramu, díky kterému můžeme například odhadnout medián nad nějakým sloupcem, který obsahuje klidně několik desítek miliard neseřazených čísel rozházených mezi deset serverů. Do Druidu dostáváme data přes <a href="https://github.com/metamx/tranquility" target="_blank" rel="external">Tranquility</a>.</p>
</li>
</ul>
<h2 id="V_čem_to_všechno_programujeme">V čem to všechno programujeme</h2><p>Vlastně toho na programování zase tak moc není. Většinu z těch aplikací “stačí” jen správně nakonfigurovat. Což bylo občas šílené peklíčko, protože když něco nefungovalo, museli jsme procházet logy na deseti různých serverech a když jsme měli štěstí, tak jsme v některých z nich opravdu nalezli nějakou chybu a když jsme měli jóó velké štěstí, tak jsme z té chyby hned pochopili, co je špatně. Nejblbější chybu, jakou jsme udělali, byla v tomto nastavení:</p>
<pre><span class="line">druid.announcer.type=batch&nbsp;</span></pre>

<p>Správně to má být samozřejmě takto:</p>
<pre><span class="line">druid.announcer.type=batch</span></pre>

<p>Že je to stejné? A co ta mezera na konci v první ukázce, hmm?! OMFG! Ale stačily dva dny debugování a našli jsme to.  </p>
<p>Protože všechny výše zmíněné aplikace jsou psané v Javě nebo v nějakém JVM jazyku jako Scala, tak i my jsme byli v podstatě donuceni psát všechno v Javě. Zkoušeli jsme Groovy, ale s tím byly spíš problémy a navíc bylo dynamicky zkompilované Groovy významně pomalejší než staticky zkompilované Groovy nebo Java. Groovy ale dále používáme pro testy, používáme <a href="https://code.google.com/p/spock/" target="_blank" rel="external">Spock</a>. Přešli jsme alespoň na Javu 8, která má lambda výrazy, streamy a takové hezké věci jako <code>Optional&lt;T&gt;</code>. </p>
<h2 id="Současný_stav">Současný stav</h2><p>Naše statistiky jsou zatím ve velmi rané alpha verzi, kdy ani nemáme žádné pořádné GUI a v ostrém provozu běžely jen několik málo dnů – ale běžely bez problémů. Popis naší architektury v následujících článcích tak berte jako popis toho, jak postupujeme, proč jsme se rozhodli, že zkusíme to a ne tamto, na jaké problémy jsme narazili, jaké problémy jednotlivé aplikace řeší, ale prozatím nečekejte žádné zkušenosti z tříletého provozu. </p>
<p>A jak všechny tyto technologie řeší ony tři problémy, které jsem nastínil nahoře? </p>
<ul>
<li>Každá technologie je horizontálně škálovatelná – obyčejně stačí zprovoznit nový server a přidat ho do Kafka/Hadoop/Druid clusteru a propustnost celého clusteru se rázem zvýší. Pro příklad: v LinkedInu přes Kafka proteče <a href="http://blog.confluent.io/2015/02/25/stream-data-platform-1/" target="_blank" rel="external">500 miliard zpráv denně</a> na bůhví kolika serverech.  </li>
<li>Kafkou i Samzou protékají data velmi rychle. Pokud to uměle nezdržujeme, protečou všechna data celým kolotočem za pár set milisekund. Pak už jen zbývá Druid jako finální databáze – a ta se také chová tak, že co do něj dostaneme, to je hned dotazovatelné, bez dalšího významného zpoždění. U některých typů úloh se proto jsme schopni dostat na velmi nízké zpoždění. </li>
<li>U Kafky a u Druidu jsme schopni konfiguračně nastavit replikaci daného úkolu. Jsme schopni zařídit, aby se každá úloha vykonávala na dvou různých serverech, takže jsme odolní vůči výpadku některé ze služeb. U Samzy zase Hadoop hlídá, jestli daná aplikace běží a pokud ne, tak ji automaticky restartuje. Dokud nenastane nějaká větší porucha, měli bychom být v pohodě. Teoreticky.  </li>
</ul>
<h2 id="Příště…">Příště…</h2><p>Příště si povíme něco málo o Kafce. </p>
<p>Stay tuned! </p>
<p>(A děkuji <a href="https://www.linkedin.com/pub/michal-matula/2/262/342" target="_blank" rel="external">Michalovi</a> za korekturu!)</p>
<div class="relatedBox"><div class="relatedArticlesBox"><h2 id="relatedArticles">Související články:</h2><ol><li><a href="/kafka/">Kafka messaging system</a></li><li><a href="/kafka-consumer/">Jak funguje Kafka consumer</a></li><li><a href="/kafka-replikace/">Jak funguje replikace v Kafce</a></li><li><a href="/samza/">Samza: distributed stream processing framework</a></li><li><a href="/samza-windowing/">Windowing v Samze</a></li><li><a href="/samza-local-state/">Uložení lokálního stavu v Samze</a></li><li><a href="/druid-io/">Druid.io: distribuovaná immutable databáze pro analytické výpočty</a></li><li><a href="/druid-io-architektura/">Architektura Druid.io</a></li><li><a href="/druid-io-ingest/">Jak Druid.io agreguje data</a></li></ol></div></div><div class="articleTags"><strong><a href="/tags/bigdata">#bigdata</a></strong></div></div></article><div style="text-align: right"><div class="fb-like" data-layout="button_count" data-action="like" data-show-faces="true" data-share="true" style="margin-top: 10px; height: 30px"></div></div><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/bigdata/" class="post__tag__link">bigdata</a></li></ul><a href="/lambda-architecture/#disqus_thread" class="post__foot-link u-fr">Komentáře</a></footer></main><footer class="foot"><div class="foot-copy u-fl"><a href="/">Programio</a> píše <a href="http://www.havrlant.cz/">Lukáš Havrlant</a></div><menu class="page-menu u-fr"><li class="page-menu__item"><a title="Previous" href="/kafka/" class="page-menu__link icon-arrow-left"></a></li><li class="page-menu__item"><a title="Next" href="/sjednoceni-hyperloglogu/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],
j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})
(document,"script","programio","embed");
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-1559810-13');ga('send','pageview');
</script><div id="fb-root"></div><script>(function(d, s, id) {
var js, fjs = d.getElementsByTagName(s)[0];
if (d.getElementById(id)) return;
js = d.createElement(s); js.id = id;
js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&appId=166268190106534&version=v2.0";
fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script></body></html>