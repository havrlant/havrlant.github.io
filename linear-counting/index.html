<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="Programio" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><title>Linear Counting: Jak odhadnout počet unikátních hodnot - Programio</title><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro"><link rel="stylesheet" href="/css/main.css" type="text/css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"> <a href="/">Programio</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Domů</a></li><li class="head-nav__item"><a href="/archives" class="head-nav__link">Archiv</a></li><li class="head-nav__item"><a href="http://www.havrlant.cz/" class="head-nav__link">O autorovi</a></li><li class="head-nav__item"><a href="/rss.xml" class="head-nav__link">RSS</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2014-10-14T21:13:23.000Z" class="post__time">14. 10. 2014</time><h1 class="post__title"><a href="/linear-counting/">Linear Counting: Jak odhadnout počet unikátních hodnot</a></h1></header><div class="post__main echo"><p>Jak bychom mohli spočítat počet unikátních hodnot v nějaké sadě dat, pokud by těchto dat bylo opravdu hodně? Můžeme mít například službu, která měří počet unikátních uživatelů na nějakém velkém webu nebo klidně na celé .cz/.com/.whatever doméně či tak něco.</p>
<h2 id="naivní-postup">Naivní postup</h2>
<p>Ok, není přece co řešit, zkrátka projdeme data a vždy si každou hodnotu uložíme právě jednou do nějaké vhodné datové struktury. V Pythonu bychom to mohli napsat asi takto (kód je zbytečně ukecaný, to je schválně):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nonunique_values = [1, 2, 3, 2, 2, 4, 1, 1, 3, 5, 2]&#10;&#10;def count_unique(values):&#10;    found = set()&#10;    for item in values:&#10;        if item not in found:&#10;            found.add(item)&#10;    return len(found)&#10;&#10;print count_unique(nonunique_values) # 5</span><br></pre></td></tr></table></figure>
<p>Funguje to. No dobře, ale co když ta data budou <a href="https://www.npmjs.org/package/node-uuid" target="_blank" rel="external">36znakové unikátní v4 identifikátory</a> a co když těch unikátních idéček bude třeba deset milionů? No… program stále vypočítá správnou hodnotu, ale kolik zabere paměti? Můžeme si to zkusit spočítat. Pro jednoduchost budeme předpokládat, že uuid ukládáme opravdu jako 36znakový string. Jedno uuid tak zabírá 36 bajtů, deset milionů idéček zabírá <a href="https://www.google.cz/?#q=(10000000*36%20byte%20in%20mb)" target="_blank" rel="external">360 MB</a>.</p>
<p>Není to úplně málo, přiznejme si. Pokud by těch unikátních idéček bylo sto milionů, šli bychom už do řádů gigabajtů zabrané paměti. A to stále počítáme čistě jen to, co zaberou data. Přidejte si nějaký overhead, který zabere třeba Python/JavaScript a můžete se do řádů gigabajtů dostat i s deseti miliony idéček:</p>
<div class="figure">
<img src="/images/trigiga.png" alt="">

</div>
<p>To nechceš. Jak z toho ven?</p>
<p>Můžeme zkusit nějak efektivněji uložit samotná idéčeka, můžeme místo Pythonu použít Céčko, čímž zásadně snížíme paměťové nároky, ale pořád to nebude ono a stále by takový program zabíral neskutečné množství místa. Zbývá si položit otázku: opravdu potřebujeme na chlup přesně vědět, jestli těch unikátních hodnot je zrovna 9 563 618? Stalo by se něco, kdybychom pracovali s počtem 9 547 666? Pokud vaše odpověď zní, že stalo a že to chcete přesně, tak prosím, jak račte. V opačném případě si pojďme ukázat postupy, jak počet unikátních hodnot v sadě dat co nejpřesněji, nejrychleji a s minimálními paměťovými nároky <em>odhadnout</em>.</p>
<h2 id="hashovací-funkce-naše-záchrana">Hashovací funkce – naše záchrana</h2>
<p>Budeme uvažovat hashovací funkci, která bere na vstupu string a na výstupu vrací nějaké n-bitové číslo. Pokud jste zvyklí spíše na hashovací funkce, které “vrací string”, tak si to prostě představte tak, že ten string zase dále zkonvertuje na číslo, na tom nic není. Počet bitů pak udává, jak velké číslo je. 8bitová funkce vrací číslo, které zabírá osm bitů a do osmi bitů lze uložit 2<sup>8</sup> různých hodnot, typicky pak celá čísla od 0 do 255. Budeme dále pracovat s 24bitovou hashovací funkcí. Taková funkce vrací 2<sup>24</sup> různých hodnot, což je 16 777 216.</p>
<p>Místo toho, abychom si ukládali hodnoty samotné, budeme si ukládat jejich 24bitové hashe. Pro uložení deseti milionů 24bitových hashů potřebujeme <a href="https://www.google.cz/?#q=(10000000*24bit%20in%20mb)" target="_blank" rel="external">30 MB</a>. To je o řád lepší než předešlých 360 MB. Kód by mohl vypadat takto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def nhash(item, n):&#10;    return hash(item) % (2 ** n)&#10;&#10;nonunique_values = [1, 2, 3, 2, 2, 4, 1, 1, 3, 5, 2]&#10;&#10;def count_unique_using_nhash(values):&#10;    found = set()&#10;    for item in values:&#10;        checksum = nhash(item, 24)&#10;        if checksum not in found:&#10;            found.add(checksum)&#10;    return len(found)&#10;&#10;print count_unique_using_nhash(nonunique_values) # 5</span><br></pre></td></tr></table></figure>
<p>Funkce <code>hash</code> je nativní funkce Pythonu a vrací celé číslo, funkce <code>nhash</code> ukazuje naivní implementaci n-bitové hashovací funkce; není důležité pochopit jak funguje, protože stejně nefunguje správně – výsledek té funkce nezabírá 24 bitů, ale to je teď jedno, jde mi o princip.</p>
<p>Pak už následuje funkce <code>count_unique_using_nhash</code>, která počítá unikátní hodnoty. Projde všechny hodnoty, spočítá jejich hash a tu uloží do proměnné <code>found</code>, pokud už tam tato hodnota není.</p>
<p>Problémem tohoto postupu je, že hashovací funkce může pro různé řetězce vrátit stejný checksum – může nastat kolize. Čím více takových kolizí nastane, tím nepřesnější výsledek dostáváme. Funkce <code>count_unique_using_nhash</code> téměř vždy vrátí menší počet unikátních hodnot, než kolik jich ve skutečnosti je.</p>
<p>A jakou hashovací funkci zvolit? Zase tak moc na tom nezáleží, ale obecně se doporučuje nějaká varianta <a href="http://en.wikipedia.org/wiki/MurmurHash" target="_blank" rel="external">MurmurHashe</a>.</p>
<h2 id="bitové-mapy">Bitové mapy</h2>
<p>Dávali jste pozor v Základech programování v jazyku C? Pokud ano, tak znáte bitové mapy. Jak by jich šlo využít?</p>
<p>Myšlenku si nastíníme na poli. My totiž nemusíme uchovávat vypočítané checksumy, my můžeme vytvořit pole o délce 2<sup>24</sup> a všechny prvky inicializujeme na nulu. Potom ve chvíli, kdy narazíme na nějaký checksum – což je číslo! – tak do tohoto pole na index <code>checksum</code> zapíšeme jedničku, čímž si zaznačíme, že tento checksum už jsme našli. Počet unikátních prvků pak bude přibližně roven počtu jedniček v tomto poli. Kód by mohl vypadat takto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def count_unique_using_array(values):&#10;    array = [0] * (2 ** 24) # seznam o delce 2^24 inicializovany na same nuly&#10;    for item in values:&#10;        array[nhash(item, 24)] = 1&#10;    return sum(array)&#10;&#10;print count_unique_using_array(nonunique_values)</span><br></pre></td></tr></table></figure>
<p>Nicméně používat pole je v tomto případě paměťově velice náročné, protože si do každé buňky potřebujeme uložit vždy buď jedničku, nebo nulu. Místo toho můžeme použít bitové pole. Abyste rozumněli, celé číslo (integer) lze uložit například do 32 bitů. Když si převedeme číslo 354 do binární soustavy, dostaneme 101100010. Číslo 354 by tak v počítači jako 32bitový integer bylo uloženo (na detaily kašleme, ju?) takto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000001 01100010</span><br></pre></td></tr></table></figure>
<p>To je takový docela milý formát, který bychom mohli využít, že? My totiž v naší funkci chceme ukládat pouze jedničky a nuly a teď jsme právě zjistili, že obyčejné číslo vlastně není nic jiného než hromada nul a jedniček (asi jako všechno v počítači…). Zkrátka, pomocí <a href="http://cs.wikipedia.org/wiki/Bitový_operátor" target="_blank" rel="external">bitových operátorů</a> můžeme uložit jedničku tak, že bude opravdu zabírat jeden bit.</p>
<p>Vrátíme se k naší funkci s polem. Pokud bychom to přepsali do bitových polí, stačilo by nám pro 24bitovou hashovací funkci bitové pole o velikosti 2<sup>24</sup> bitů, což jsou <a href="https://www.google.cz/?#q=(2%5E24bit%20in%20mib)" target="_blank" rel="external">2 MiB</a>. To je slušný upgrade!</p>
<p>Při použití 32bitové hashovací funkce, která má 2<sup>32</sup> různých výstupních hodnot, což je 4 294 967 296, bychom potřebovali bitové pole o velikosti půl giga. To není úplně špatné na to, že tím jsme schopni počítat unikáty až někam do řádů miliard.</p>
<h2 id="linear-counting"> Linear Counting</h2>
<p>Už jsem zmínil, že při použití hashovací funkce dostáváme pouze odhad počtu unikátních hodnot. Tento odhad je tím více nepřesný, čím více se počet unikátních hodnot blíží počtu různých výstupních hodnot hashovací funkce. Je logické, že když máme sadu dat, ve které je pět miliard unikátních hodnot, že to 24bitovou hashovací funkcí prostě nespočítáme.</p>
<p>Nicméně odhad, který vypočítáme pomocí hashovacích funkcí, lze dále zpřesnit. Používá se k tomu jednoduchá myšlenka – čím více unikátních hodnot v sadě dat je, tím je pravděpodobnější, že budou časem vznikat kolize. (Kolize = dva různé vstupy mají stejný výstup z hashovací funkce, stejný checksum.) Teď budeme trochu počítat, proto si zavedeme pár proměnných:</p>
<ul>
<li>Budeme pracovat s <code>n</code> bitovou hashovací funkcí <code>h</code>.</li>
<li>Počet všech možných výstupů funkce <code>h</code> je tak roven <code>2<sup>n</sup></code>. Tento počet si označíme písmenem <code>m</code>, tedy: <code>m=2<sup>n</sup></code>.</li>
<li>Bitové pole, do kterého si budeme ukládat, které checksumy jsme našli, si označíme velkým písmenem <code>A</code>. Pole <code>A</code> má délku <code>m</code>.</li>
<li>Pokud projdeme naším algoritmem celou sadu dat, budou některé hodnoty v bitovém poli rovny nule a některé jedničce. Nás bude hlavně zajímat podíl “počet nul děleno délka pole”, což nám udává relativní podíl nul v bitovém poli. Na začátku je ten podíl rovný 1, protože pole je inicializováno na samé nuly. Pokud by to bylo fifty-fifty, podíl by byl roven jedné polovině atp. Tuto hodnotu si označíme <code>Z</code> a vypočítáme jako <code>Z = počet nul / m</code>.</li>
</ul>
<p>V tuto chvíli platí, že čím vyšší hodnota <code>Z</code>, tím vyšší máme jistotu, že náš odhad počtu unikátů je přesný. Pokud například projdeme prázdnou sadu dat, zůstanou v bitovém poli samé nuly a hodnota <code>Z</code> bude rovna jedné – máme tak úplnou jistotu, že v naší sadě dat je tolik unikátních prvků, kolik je v bitovém poli jedniček – nula.</p>
<p>Pokud je hodnota <code>Z</code> rovna 0,99, znamená to, že je bitové pole jedničkami zaplněno z jedné setiny. 99 % pole obsahuje nuly. To je ještě dobré, je pravděpodobné, že během výpočtu nenastalo příliš kolizí a bude třeba žádná nebo jen minimální oprava. Pokud je ale hodnota <code>Z</code> rovna 0,05, jen 5 % pole zůstalo nulové a pravděpodobně jsme během výpočtu narazili na mnoho a mnoho kolizí – bude třeba velká oprava.</p>
<p>Jak ale tuto opravu vypočítat? Pomůžeme si <a href="http://matematika.cz/logaritmy" target="_blank" rel="external">logaritmem</a>, což je funkce, která má tento tvar:</p>
<center>
<img src="/images/ln.svg" alt="">
</center>
<p>Nás bude zajímat ta červená část na intervalu <code>(0, 1&gt;</code>. Pokud budeme na ose <code>x</code> nanášet hodnotu <code>Z</code>, tak docílíme toho, že čím vyšší <code>Z</code>, tím více se bude hodnota <code>y</code> přibližovat nule. A naopak – čím menší <code>Z</code>, tím menší bude hodnota <code>y</code>. Výsledný odhad vypočteme tak, že toto číslo vynásobíme <code>-m</code>. Všimněte si, že pro dostatečně nízkou hodnotu <code>Z</code> dostaneme číslo, které je dokonce menší než <code>-1</code> a pokud tuto hodnotu vynásobíme <code>-m</code>, získáme odhad, který je větší než <code>m</code>: odhadli jsme, že počet unikátů je větší než počet všech možných checksumů, které mohou vylézt z hashovací funkce <code>h</code>.</p>
<p>Celý vzorec pro výpočet počtu <code>p</code> unikátních hodnot by vypadal takto:</p>
<center>
<img src="/images/linearcounting.svg" alt="">
</center>
<p>Implementace (bez bitových polí, jen s obyčejnými poli) by mohla vypadat takto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from uuid import uuid4&#10;from math import log&#10;&#10;number_of_unique_values = 10000&#10;nonunique_values = [uuid4() for _ in xrange(number_of_unique_values)]&#10;nonunique_values += nonunique_values&#10;&#10;def nhash(item, n):&#10;    return hash(item) % (2 ** n)&#10;&#10;def count_unique_using_array(values, n):&#10;    array = [0] * (2 ** n)&#10;    for item in values:&#10;        array[nhash(item, n)] = 1&#10;    return sum(array)&#10;&#10;def linear_counting(values, n):&#10;    estimate = count_unique_using_array(values, n)&#10;    m = 2 ** n&#10;    number_of_zeros = m - estimate&#10;    Z = float(number_of_zeros) / m &#10;    p = (-m) * log(Z)      # log je zde prirozeny logaritmus o zakladu e&#10;    p = int(round(p))&#10;    print &#34;Debug info: estimate=%s, m=%s, number_of_zeros=%s, Z=%s, p=%s&#34; % \&#10;          (estimate, m, number_of_zeros, Z, p)&#10;    return p&#10;&#10;print &#34;Cardinality: %s&#34; % linear_counting(nonunique_values, 16)</span><br></pre></td></tr></table></figure>
<p>Ve funkci <code>linear_counting</code> nejprve vypočítáme první odhad pomocí předchozího algoritmu, který využívá <code>n</code>-bitovou hashovací funkci. Potom vypočítáme podíl nul v poli a provedeme opravu podle vzorce. Logaritmus v kódu je přirozený logaritmus. Proměnná <code>nonunique_values</code> obsahuje <code>number_of_unique_values</code> unikátních řetězců, v tomto příkladě je tak v seznamu <code>nonunique_values</code> deset tisíc unikátních hodnot. Ten divný kód na šestém řádku zařídí to, aby v poli bylo více stejných hodnot: prostě na konec seznamu připojíme tentýž seznam hodnost a každá hodnota je tak v poli dvakrát. A pak už počítáme. Funkce by ideálně měla vrátit, že seznam obsahuje deset tisíc unikátů. Výstup:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug info: estimate=9289, m=65536, number_of_zeros=56247, Z=0.858261108398, p=10016&#10;Cardinality: 10016</span><br></pre></td></tr></table></figure>
<p>Protože se vždy generuje jiný seznam <code>nonunique_values</code>, tak se výsledky budou s každým voláním lišit. Použili jsme 16bitovou hashovací funkci. Vidíme, že první odhad z funkce <code>count_unique_using_array</code> byl, že seznam obsahuje 9289 unikátů. Tento odhad jsme korekcí zpřesnili na 10 016, což už je celkem slušné: náš odhad je větší jen o 0,16 %, zatímco předtím byl menší o 7,11 % – to je docela hodně.</p>
<p>Pokud bychom vzali “větší” hashovací funkci, například 24bitovou, dostali bychom přesnější výsledek:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ebug info: estimate=9997, m=16777216, number_of_zeros=16767219, Z=0.999404132366, p=10000&#10;Cardinality: 10000</span><br></pre></td></tr></table></figure>
<p>Už samotný původní odhad byl OK, zpřesnění už se dostalo na rovných deset tisíc. Pro ukázku si můžeme zkusit milion unikátních idéček, tj. <code>number_of_unique_values = 1000000</code>. S 24bitovou hashovací funkcí se dostaneme na tyto výsledky:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug info: estimate=971033, m=16777216, number_of_zeros=15806183, Z=0.94212192297, p=1000267&#10;Cardinality: 1000267</span><br></pre></td></tr></table></figure>
<p>To jde. Přitom, pokud to implementujeme jako bitové pole, tak by nám pole mělo sežrat jen zmíněné dva megabajty (+ co sežere jazyk). Za mě docela dobré. <em>But we can do better!</em> Much better. Ale až příště.</p>
<p>V mezičase si můžete přečíst článek <a href="http://dblab.kaist.ac.kr/Publication/pdf/ACM90_TODS_v15n2.pdf" target="_blank" rel="external">A Linear-Time Probabilistic Counting Algorithm for Database Applications [PDF]</a>. Anebo můžete pokračovat na další díl série: <a href="/min-value/">algoritmus min-value</a>.</p>
<div class="relatedBox"><div class="relatedArticlesBox"><h2 id="relatedArticles">Související články:</h2><ol><li><a href="/min-value/">Min Value: Jak odhadnout počet unikátních hodnot</a></li><li><a href="/loglog/">LogLog: Jak odhadnout počet unikátních hodnot</a></li><li><a href="/hyperloglog/">HyperLogLog: Jak odhadnout počet unikátních hodnot</a></li><li><a href="/sjednoceni-hyperloglogu/">Sjednocení Hyperloglogu</a></li></ol></div></div><div class="articleTags"><strong><a href="/tags/algoritmy">#algoritmy</a></strong>, <strong><a href="/tags/hyperloglog">#hyperloglog</a></strong></div></div></article><div style="text-align: right"><div class="fb-like" data-layout="button_count" data-action="like" data-show-faces="true" data-share="true" style="margin-top: 10px; height: 30px"></div></div><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/algoritmy/" class="post__tag__link">algoritmy</a></li><li class="post__tag__item"><a href="/tags/hyperloglog/" class="post__tag__link">hyperloglog</a></li></ul><a href="/linear-counting/#disqus_thread" class="post__foot-link u-fr">Komentáře</a></footer></main><footer class="foot"><div class="foot-copy u-fl"><a href="/">Programio</a> píše <a href="http://www.havrlant.cz/">Lukáš Havrlant</a></div><menu class="page-menu u-fr"><li class="page-menu__item"><a title="Previous" href="/min-value/" class="page-menu__link icon-arrow-left"></a></li><li class="page-menu__item"><a title="Next" href="/jak-v-javascriptu-testovat-funkce-s-prisliby/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],
j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})
(document,"script","programio","embed");
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-1559810-13');ga('send','pageview');
</script><div id="fb-root"></div><script>(function(d, s, id) {
var js, fjs = d.getElementsByTagName(s)[0];
if (d.getElementById(id)) return;
js = d.createElement(s); js.id = id;
js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&appId=166268190106534&version=v2.0";
fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script></body></html>