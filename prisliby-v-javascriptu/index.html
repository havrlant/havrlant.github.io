<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="Programio" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><title>Přísliby v JavaScriptu - Programio</title><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro"><link rel="stylesheet" href="/css/main.css" type="text/css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"> <a href="/">Programio</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Domů</a></li><li class="head-nav__item"><a href="/archives" class="head-nav__link">Archiv</a></li><li class="head-nav__item"><a href="http://www.havrlant.cz/" class="head-nav__link">O autorovi</a></li><li class="head-nav__item"><a href="/rss.xml" class="head-nav__link">RSS</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2014-09-30T17:32:05.000Z" class="post__time">30. 9. 2014</time><h1 class="post__title"><a href="/prisliby-v-javascriptu/">Přísliby v JavaScriptu</a></h1></header><div class="post__main echo"><p>Pár poznámek o javasriptových příslibech, se kterými jsem se teď začal v práci nějak víc setkávat. Přísliby slouží především k zpřehlednění kódu a zabraňují tzv. callback hell.</p>
<h2 id="callback-v-callbacku-v-callbacku">Callback v callbacku v callbacku</h2>
<p>Pokud programujete v Node.js, jistě znáte, nebo si dokážete představit, pojem callback hell. Běžný kód v Node.js, který používá několik asynchronních operací, totiž vypadá nějak takto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbClient.get(&#34;obsah&#34;, function(err, data) &#123;&#10;    if (err) &#123;&#10;        return console.error(err);&#10;    &#125;&#10;    fs.writeFile(&#34;soubor.txt&#34;, data, function(err) &#123;&#10;        if (err) &#123;&#10;            return console.error(err);&#10;        &#125;&#10;    &#125;);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>…na což lze reagovat jen takto:</p>
<div class="figure">
<img src="/images/omg.gif" alt="">

</div>
<p>Milion calbacků v milionu jiných callbacků, ve kterých musíte milionkrát ověřit, jestli existuje <code>err</code> a když ano, tak nějak reagovat. Nejlépe zase zavolat nějaký callback, který zavolá řetězec jiných callbacků. Debugování takového kódu je příjemné asi jako sezení na záchodě bez WiFi. Jak z toho ven?</p>
<p>Nejvíce se mi líbí používání příslibů/promisů. Příslib je jen jakási obálka nad hromadou callbacků, která ale umožňuje zásadně přehlednější syntaxi pro řetězení callbacků a hlavně pro odchytávání chyb. Pokud by náš <code>dbClient</code> a naše <code>fs</code> knihovna používala/vracela přísliby, vypadal by předchozí kód takto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbClient.getAsync(&#34;obsah&#34;).then(function(data) &#123;&#10;    return fs.writeFileAsync(&#34;soubor.txt&#34;, data);&#10;&#125;).catch(function(err) &#123;&#10;    console.error(err);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>(Suffix <code>Async</code> jsem tam přidal záměrně, abych odlišil původní funkce a nové funkce, které pracují s přísliby). Obě funkce, které braly jako parametr callback ho nyní neberou a namísto toho vrací objekt reprezentující náš příslib. Tento objekt má dvě základní metody: <code>then</code> a <code>catch</code>. Asi si dokážete představit, jak má kód fungovat: pokud dotaz z databáze vrátí nějaká data, zavolá se funkce předaná v <code>then</code> metodě. Pokud nastane chyba, zavolá se funkce předaná v <code>catch</code> metodě.</p>
<p>Základní idea příslibů je, že příslib je objekt, který nám slibuje, že jednoho dne (až se přečte soubor z disku, až se vyhodnotí dotaz v databázi…) nám vrátí data, o které jsme žádali anebo vrátí chybu. Přitom příslib nijak nezdržuje načítání – přísliby jsou stále asynchronní, stejně jako callbacky.</p>
<h2 id="jak-něco-takového-implementovat">Jak něco takového implementovat</h2>
<p>Asi ne úplně snadno, aby to fungovalo správně. Naštěstí už existují knihovny, které tuto myšlenku implementovaly za vás, nejvíce se mi líbí <a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="external">Bluebird</a>. V další části článku tak budu popisovat práci s touto knihovnou. Instalace je jednoduchá:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install bluebird</span><br></pre></td></tr></table></figure>
<p>A v kódu:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var Promise = require(&#34;bluebird&#34;);</span><br></pre></td></tr></table></figure>
<p>Knihovna dokonce umožňuje “zpříslibovat” existující knihovny. Takže pokud napíšete</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fs = Promise.promisifyAll(require(&#34;fs&#34;));</span><br></pre></td></tr></table></figure>
<p>přidá vám k modulu <code>fs</code> metody se suffixem <code>Async</code>, které už pracují s promisy. Místo <code>readFile</code> můžete používat metodu <code>readFileAsync</code> apod. Viz příklady níže nebo výše.</p>
<h2 id="první-krůčky-s-vlastními-přísliby">První krůčky s vlastními přísliby</h2>
<p>Abychom mohli s přísliby pracovat, potřebujeme jako první nějaký příslib vytvořit. Úplně nejjednodušší je metoda <code>Promise.resolve(value)</code>, která udělá to, že vrátí nový příslib, který se později vyhodnotí na hodnotu <code>value</code>. Příklad:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise.resolve(42);</span><br></pre></td></tr></table></figure>
<p>Tento kód vlastně nic neudělá. Vytvořili jsme nový příslib, který se resolvnul na číslo 42 … ale s touto hodnotou jsme nijak dál nepracovali. Přidáme metodu <code>then</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise.resolve(42);&#10;promise.then(function(data) &#123;&#10;    console.log(&#34;Ziskal jsem:&#34;, data);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Program by vypsal: “Ziskal jsem: 42”. Stalo se to, že jsme vytvořili nový příslib, který se hned vyhodnotil na číslo 42. Toto číslo se pak odchytlo v prvním <code>then</code> bloku. Přísliby můžeme i řetězit, takže bychom mohli napsat například toto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise.resolve(42);&#10;promise.then(function(data) &#123;&#10;    console.log(&#34;Ziskal jsem:&#34;, data);&#10;    return data *&#160;10;&#10;&#125;).then(function(data) &#123;&#10;    console.log(&#34;A ted jsem ziskal:&#34;, data);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Tu hodnotu, kterou jsme vrátili v prvním <code>then</code> zase odchytíme v druhém <code>then</code>, takže se vypíše</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ziskal jsem: 42&#10;A ted jsem ziskal: 420</span><br></pre></td></tr></table></figure>
<p>Knihovna je navíc natolik chytrá, že pozná, jestli vracíte příslib nebo nějakou normální hodnotu a podle toho se zachová.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise.resolve(42);&#10;promise.then(function(data) &#123;&#10;    console.log(&#34;Ziskal jsem:&#34;, data);&#10;    return data *&#160;10;&#10;&#125;).then(function(data) &#123;&#10;    console.log(&#34;A ted jsem ziskal:&#34;, data);&#10;    return Promise.resolve(data * 10);&#10;&#125;).then(function(data) &#123;&#10;    console.log(&#34;A nakonec jsem ziskal:&#34;, data);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Program by vypsal:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ziskal jsem: 42&#10;A ted jsem ziskal: 420&#10;A nakonec jsem ziskal: 4200</span><br></pre></td></tr></table></figure>
<p>Na čtvrtém řádku jsme vrátili číslo 420, zatímco na sedmém řádku jsme vrátili příslib, který se resolvne na 4200. Přitom v argumentu <code>data</code> už jsme vždy získali výslednou hodnotu – v posledním <code>then</code> jsme v argument <code>data</code> neobdrželi příslib, ale opravdu číslo 4200.</p>
<h2 id="odchytávání-chyb">Odchytávání chyb</h2>
<p>Co by se stalo, kdybychom uprostřed příslibu vyhodili výjimku?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise.resolve(42);&#10;promise.then(function(data) &#123;&#10;    throw new Error(&#34;Milos Zeman se stal prezidentem&#34;);&#10;&#125;).then(function(data) &#123;&#10;    console.log(&#34;A ted jsem ziskal:&#34;, data);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Program by spadnul a vyhodil by “Possibly unhandled Error: Milos Zeman se stal prezidentem”. Proč se tam vypsalo zrovna “Possibly unhandled Error” je teď jedno, otázkou je, jak to spravit? Jednoduše tak, že přidáme <code>catch</code> blok:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise.resolve(42);&#10;promise.then(function(data) &#123;&#10;    throw new Error(&#34;Milos Zeman se stal prezidentem&#34;);&#10;&#125;).then(function(data) &#123;&#10;    console.log(&#34;A ted jsem ziskal:&#34;, data);&#10;&#125;).catch(function(err) &#123;&#10;    console.error(&#34;Zachytil jsem&#34;, err);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Teď už program správně vypíše “Zachytil jsem [Error: Milos Zeman se stal prezidentem]”. Všimněte si, že program se vůbec nedostal k druhému <code>then</code>, protože chyba nastala před ním. Tím, že vyhodíme uprostřed příslib výjimku, nastavíme příznak příslibu na rejected. Podobného chování docílíme také metodou <code>Promise.reject(err)</code>. Tato metoda se chová podobně jako <code>Promise.resolve</code>, jen s tím, rozdílem, že vytvořený příslib bude hned rejected, takže se nezavolá <code>then</code>, ale až <code>catch</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var promise = Promise.reject(new Error(&#34;Tomio Okamura se stal nasim dalsim prezidentem&#34;));&#10;promise.then(function(data) &#123;&#10;    console.log(&#34;Vypisuji z then:&#34;, data);&#10;&#125;).catch(function(err) &#123;&#10;    console.error(&#34;Vypisuji z catch:&#34;, err);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Vypíše se: “Vypisuji z catch: [Error: Tomio Okamura se stal nasim dalsim prezidentem]”. Úplně nejvíc nejlepší fíčura metody <code>catch</code> je, že nám dovoluje odchytávat jen výjimky nějakého typu tím, že daný typ uvedeme jako argument metody <code>catch</code>. Příklad:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var promise = Promise.reject(new TypeError(&#34;Tomio Okamura se stal nasim dalsim prezidentem&#34;));&#10;promise.catch(ReferenceError, function(err) &#123;&#10;    console.error(&#34;Vypisuji z catch/ReferenceError:&#34;, err);&#10;&#125;).catch(TypeError, function(err) &#123;&#10;    console.error(&#34;Vypisuji z catch/TypeError:&#34;, err);&#10;&#125;).catch(function(err) &#123;&#10;    console.error(&#34;Vypisuji z catch:&#34;, err);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>V kódu máme třikrát <code>catch</code>. Dva reagují na výjimky konkrétního typu a jeden obecný. Protože jsme vytvořili výjimku typu <code>TypeError</code>, chytil se pouze jeden <code>catch</code>, ostatní ne. Vypsalo by se: “Vypisuji z catch/TypeError: [TypeError: Tomio Okamura se stal nasim dalsim prezidentem]”. Když bude úplně nejhůř, můžete jako první parametr v <code>catch</code> metodě předat i predikát testující chybu:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var is6xxError = function(err) &#123; return err.code &#62;= 600 &#38;&#38; err.code &#60; 700 &#125;;&#10;var error = new Error(&#34;Stanislav Huml pouzil Facebook&#34;);&#10;error.code = 666;&#10;Promise.reject(error).catch(is6xxError, function(err) &#123;&#10;    console.error(&#34;Specificky catch:&#34;, err);&#10;&#125;).catch(function(err) &#123;&#10;    console.error(&#34;Obecny catch:&#34;, err);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Metoda <code>catch</code> nyní bere dva argumenty. První funkce přitom říká, že tento <code>catch</code> ošetřuje všechny chyby, které mají chybový kód 6xx. Program by tak vypsal: “Specificky catch: { [Error: Stanislav Huml pouzil Facebook] code: 666 }”.</p>
<h3 id="asynchronní-přísliby">Asynchronní přísliby</h3>
<p>Schválně, co se vypíše teď?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#34;Z prislibu&#34;).then(console.log);&#10;console.log(&#34;Po prislibu&#34;);</span><br></pre></td></tr></table></figure>
<p>Abyste rozuměli: vypíše se první “Z prislibu” nebo “Po prislibu?”? Přísliby se vyhodnocují asynchronně, takže se funkce v <code>then</code> se zavolá až ve chvíli, kdy skončí vykonávání celého současného kódu. Nejprve se vytvoří příslib a nastavíme mu <code>then</code> metodou, co se má stát, až bude příslib resolvnutý. Pak pokračujeme dalším řádkem, tj. tím console.logem. V tuto chvíli už nám došel synchronní kód, takže začneme zpracovávat kód, který jsme volali asynchronně, tj. náš příslib. Konečně se zavolá funkce z <code>then</code> metody.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Po prislibu&#10;Z prislibu</span><br></pre></td></tr></table></figure>
<p>I kdybychom tam měli nějaký takový kód…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#34;Z prislibu&#34;).then(console.log);&#10;for (var i = 0; i &#60; 10000; i++) console.log(i);&#10;console.log(&#34;Po prislibu&#34;);</span><br></pre></td></tr></table></figure>
<p>…tak se nejdřív 10000krát vypíše hodnota <code>i</code>, pak se vypíše “Po prislibu” a až pak se vypíše “Z prislibu”. Je to v podstatě podobné, jako kdybychom měli tento kód:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&#34;soubor.txt&#34;, &#34;utf-8&#34;, function(err, data) &#123;&#10;    if (!err) &#123;&#10;        console.log(data);&#10;    &#125;&#10;&#125;);&#10;console.log(&#34;Tu se Zemanem nechci. Nevim, kterou stranu bych mel oliznout.&#34;);</span><br></pre></td></tr></table></figure>
<p>Také se jako první vypíše reakce paní, která si kupuje známku na dopis a až potom se vypíše obsah souboru. Reakce by se vypsala jako první, i kdybychom čtení ze souboru přepsali do příslibů:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFileAsync(&#34;soubor.txt&#34;, &#34;utf-8&#34;).then(function(data) &#123;&#10;    console.log(data);&#10;&#125;);&#10;console.log(&#34;Tu se Zemanem nechci. Nevim, kterou stranu bych mel oliznout.&#34;);</span><br></pre></td></tr></table></figure>
<h2 id="vnořené-přísliby">Vnořené přísliby</h2>
<p>Trochu nepořádek nastává ve chvíli, kdy používáte vnořené přísliby. Co vypíše tento program?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFileAsync(&#34;prvnisoubor.txt&#34;, &#34;utf-8&#34;).then(function(prvnidata) &#123;&#10;    fs.readFileAsync(&#34;druhysoubor.txt&#34;, &#34;utf-8&#34;);&#10;&#125;).then(function(druhadata) &#123;&#10;    console.log(druhadata);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Vypíše obsah prvního, nebo druhého souboru? … Chvíle napětí … Program vypíše <code>undefined</code>. Nejprve se přečte první soubor a jeho obsah se uloží do argumentu <code>prvnidata</code>. V tuto chvíli se vykoná kód <code>fs.readFileAsync(&quot;druhysoubor.txt&quot;, &quot;utf-8&quot;);</code>, tj. vytvoří se příslib přečtení druhého souboru. A s tímto příslibem jaksi nic neděláme, takže tento příslib je zahozen. Když pak voláme další <code>then</code>, tak mu vlastně nepředáváme žádná data. Chybí nám tam jeden <code>return</code> na druhém řádku:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFileAsync(&#34;prvnisoubor.txt&#34;, &#34;utf-8&#34;).then(function(prvnidata) &#123;&#10;    return fs.readFileAsync(&#34;druhysoubor.txt&#34;, &#34;utf-8&#34;);&#10;&#125;).then(function(druhadata) &#123;&#10;    console.log(druhadata);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>V tuto chvíli už funkce v prvním <code>then</code> vrací příslib, který jsem vytvořili kódem <code>fs.readFileAsync(&quot;druhysoubor.txt&quot;, &quot;utf-8&quot;);</code>. Logika v tuto chvíli říká, že by se do argumentu <code>druhadata</code> měl dostat právě tento příslib. Nicméně to není pravda – pokud vrátíme příslib, knihovna už je natolik chytrá, že pochopí, že nechceme ani tak ten příslib, jako spíš tu hodnotu, na kterou se má příslib vyhodnotit. Takže <code>console.log</code> vypíše obsah druhého souboru.</p>
<p>Na ten chybějící <code>return</code> si dávejte pozor, je to celkem častá chyba, která se blbě hledá. Něco jako chybějící return v rekurzivní funkci – taky to vypadá, že celá funkce funguje správně a ve výsledku vrací <code>undefined</code>. Hehe.</p>
<h2 id="další-způsoby-jak-vytvořit-příslib">Další způsoby, jak vytvořit příslib</h2>
<h3 id="promise.promisify"><code>Promise.promisify</code></h3>
<p>Vůbec nejlepší je přísliby nikdy ručně nevytvářet, ale získávat je z knihoven, které už s přísliby pracují. Pokud dané knihovny s přísliby nepracují, můžete použít metodu <code>Promise.promisifyAll</code>, která projde celý předaný objekt a přidá k objektu nové metody, které už vrací přísliby. Všem novým metodám přidá suffix <code>Async</code>. Příklad už jste viděli. Pokud nechcete zpříslibovat celou knihovnu, můžete vytovřit příslib jen z jedné metody pomocí <code>Promise.promisify</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var readFileAsync = Promise.promisify(fs.readFile);&#10;readFileAsync(&#34;soubor.txt&#34;, &#34;utf-8&#34;).then(function(data) &#123;&#10;    console.log(data);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Občas tento způsob nefunguje, protože když předáte referenci na funkci jako v tomto případě, tak ztratíte původní <code>this</code> kontext. V takovém případě použijte druhý parametr. (Zrovna u <code>fs.readFile</code> to není nutné, ale pro příklad…)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var readFileAsync = Promise.promisify(fs.readFile, fs);</span><br></pre></td></tr></table></figure>
<h3 id="new-promise"><code>new Promise</code></h3>
<p>Když vše selže, použijte <code>new Promise</code>. Syntaxe je už celkem složitá:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var isTomorrow = false;&#10;var promise = new Promise(function(resolve, reject) &#123;&#10;    if (isTomorrow) &#123;&#10;        resolve(&#34;Je zitra.&#34;);&#10;    &#125; else &#123;&#10;        reject(new Error(&#34;Neni zitra&#34;));&#10;    &#125;&#10;&#125;);&#10;promise.then(console.log).catch(console.error);</span><br></pre></td></tr></table></figure>
<p>Náš <code>Promise</code> bere jako parametr funkci o dvou parametrech. Oba parametry jsou zase funkce. První je <code>resolve</code> – tuto funkci zavoláme, když chceme příslib úspěšně vyhodnotit a předáme mu hodnotu, kterou má příslib dávat dál. Druhá funkce je <code>reject</code>, tu použijeme ve chvíli, kdy chceme příslib rejectnout. Tento kód by tak skončil rejectnutím, <code>then</code> by se přeskočil a zavolal by se až <code>console.error</code>, který by vypsal chybu.</p>
<p>Tento způsob vytváření příslibů využívejte jen když nebude zbytí.</p>
<h2 id="práce-se-seznamy">Práce se seznamy</h2>
<p>Přísliby nám umožňují krásně a jednoduše pracovat s více asynchronními požadavky. Pokud máme v poli tři názvy souborů, které chceme načíst, můžeme je všechny tři asynchronně načíst takto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var filenames = [&#34;soubor1.txt&#34;, &#34;soubor2.txt&#34;, &#34;soubor3.txt&#34;];&#10;var promises = filenames.map(function(filename) &#123;&#10;    return fs.readFileAsync(filename, &#34;utf-8&#34;);&#10;&#125;);&#10;Promise.all(promises).then(function(contents) &#123;&#10;    console.log(contents);&#10;&#125;).catch(function(err) &#123;&#10;    console.error(err);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Nejprve projdeme všechny názvy a vytvoříme tři přísliby. Ty si uložíme do proměnné <code>promises</code>. Pak zavoláme <code>Promise.all(promises)</code>, čímž říkáme: hele, počkej, až budou všechny přísliby resolvnuty a pak mi obsahy všech tří souborů vrať jako pole do argumentu <code>contents</code>. A pokud během načítání nastane chyba, vypiš ji. Nemusíte se tak starat o žádnou další synchronizaci, o vše se za vás postará <code>Promise.all</code>. Ještě jednodušší je použít <code>Promise.map</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var filenames = [&#34;soubor.txt&#34;, &#34;soubor.txt&#34;, &#34;soubor.txt&#34;];&#10;Promise.map(filenames, function(filename) &#123;&#10;    return fs.readFileAsync(filename, &#34;utf-8&#34;);&#10;&#125;).then(function(contents) &#123;&#10;    console.log(contents);&#10;&#125;).catch(function(err) &#123;&#10;    console.error(err);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Zkuste si představit, jak by se tohle implementovalo, kdybyste používali čisté callbacky.</p>
<div class="figure">
<img src="/images/no.gif" alt="">

</div>
<p>A to by pro dnešek bylo všechno. Snad vám tento krátký článek pomůže.</p>
<p>A jestli vás článek opravdu zaujal, <a href="http://www.ibillboard.com/cs/spolecnost/spolecnost/kariera/202-vyvojar-nodejs-javascript">tak pojďte pracovat k nám do firmy!</a> Podobných problémů řešíme mraky.</p><div class="relatedBox"><div class="relatedArticlesBox"><h2 id="relatedArticles">Související články:</h2><ol><li><a href="/jak-v-javascriptu-testovat-funkce-s-prisliby/">Jak v JavaScriptu testovat funkce s přísliby</a></li></ol></div></div><div class="articleTags"><strong><a href="/tags/node.js">#node.js</a></strong></div></div></article><div style="text-align: right"><div class="fb-like" data-layout="button_count" data-action="like" data-show-faces="true" data-share="true" style="margin-top: 10px; height: 30px"></div></div><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/node-js/" class="post__tag__link">node.js</a></li></ul><a href="/prisliby-v-javascriptu/#disqus_thread" class="post__foot-link u-fr">Komentáře</a></footer></main><footer class="foot"><div class="foot-copy u-fl"><a href="/">Programio</a> píše <a href="http://www.havrlant.cz/">Lukáš Havrlant</a></div><menu class="page-menu u-fr"><li class="page-menu__item"><a title="Previous" href="/jak-pracovat-s-obrazky-v-hexoio/" class="page-menu__link icon-arrow-left"></a></li><li class="page-menu__item"><a title="Next" href="/deploy-hexoio/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],
j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})
(document,"script","programio","embed");
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-1559810-13');ga('send','pageview');
</script><div id="fb-root"></div><script>(function(d, s, id) {
var js, fjs = d.getElementsByTagName(s)[0];
if (d.getElementById(id)) return;
js = d.createElement(s); js.id = id;
js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&appId=166268190106534&version=v2.0";
fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script></body></html>