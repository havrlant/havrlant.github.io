<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="Programio" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><title>Jak v JavaScriptu testovat funkce s přísliby - Programio</title><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro"><link rel="stylesheet" href="/css/main.css" type="text/css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"> <a href="/">Programio</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Domů</a></li><li class="head-nav__item"><a href="/archives" class="head-nav__link">Archiv</a></li><li class="head-nav__item"><a href="http://www.havrlant.cz/" class="head-nav__link">O autorovi</a></li><li class="head-nav__item"><a href="/rss.xml" class="head-nav__link">RSS</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2014-10-07T16:57:24.000Z" class="post__time">7. 10. 2014</time><h1 class="post__title"><a href="/jak-v-javascriptu-testovat-funkce-s-prisliby/">Jak v JavaScriptu testovat funkce s přísliby</a></h1></header><div class="post__main echo"><p>Z <a href="/prisliby-v-javascriptu/">minulého článku o příslibech v JavaScriptu</a> už víme, co jsou to přísliby či promisy a jak s nimi pracovat. Protože ale každý programátor píše testy – a kdo ne, debuguje dodnes – podíváme se na to, jak nějak rozumně otestovat kód, který přísliby používá.</p>
<p>Pro příklad mějme funkci, která odněkud přečte konfiguraci a vrátí ji jako příslib. Pokud bychom tu funkci hodně zjednodušili, mohli bychom ji napsat takto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var Promise = require(&#39;bluebird&#39;);&#10;&#10;var getConfig = function () &#123;&#10;    // tady by se realne config precetl z disku/databaze/whatever&#10;    return Promise.resolve(&#123;&#10;        port: 1234,&#10;        host: &#34;localhost&#34;&#10;    &#125;);&#10;&#125;&#10;&#10;getConfig().then(function (config) &#123;&#10;    console.log(config)&#10;&#125;);&#10;&#10;// &#123; port: 1234, host: &#39;localhost&#39; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="naivní-nefunkční-cesta">Naivní nefunkční cesta…</h2>
<p>OK, máme funkci, která vrací příslib, který se resolvne na objekt <code>{ port: 1234, host: 'localhost' }</code>. Jak ji otestovat? Na testy použijeme <a href="http://visionmedia.github.io/mocha/" target="_blank" rel="external">Mochu</a>. Očekáváme, že dostaneme config, který je objekt a má dvě property: <code>port</code> a <code>host</code>. Testy bychom mohli mohli napsat takto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe(&#39;getConfig&#39;, function () &#123;&#10;&#10;    it(&#39;should return an object&#39;, function () &#123;&#10;        getConfig().should.be.Object;&#10;    &#125;);&#10; &#10;    it(&#39;should return config with valid port&#39;, function () &#123;&#10;        getConfig().should.have.property(&#39;port&#39;).which.is.Number;&#10;    &#125;);&#10;&#10;    it(&#39;should return config with valid host&#39;, function () &#123;&#10;        getConfig().should.have.property(&#39;host&#39;).which.is.String;&#10;    &#125;);&#10;&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Radostně pustíme testy a …</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 passing (11ms)&#10;2 failing&#10;&#10;1) getConfig should return config with valid port:&#10;   AssertionError: expected &#123; _bitField: 268435456, ...</span><br></pre></td></tr></table></figure>
<p>Co se stalo? Samozřejmě se stalo to, že funkce getConfig vrací <em>příslib</em>, nevrací přímo náš objekt. První test prošel, protože příslib je objekt, ale příslib už nemá vlastnosti <code>port</code> a <code>host</code>, proto zbylé testy spadly. Jak testy opravit?</p>
<h2 id="naivní-funkční-cesta">Naivní funkční cesta</h2>
<p>Pokud chceme otestovat hodnotu, na kterou se resolvne náš příslib, musíme použít metodu <code>then</code>, abychom se k té resolvnuté hodnotě dostali. Test na validní port bychom mohli napsat například takto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it(&#39;should return config with valid port&#39;, function () &#123;&#10;    getConfig().then(function (config) &#123;&#10;        config.should.have.property(&#39;port&#39;).which.is.Number;&#10;    &#125;);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Nejprve vyhodnotíme příslib, získáme hodnotu, na kterou se resolvuje a až tu kontrolujeme. Všechny tři testy bychom mohli přepsat takto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe(&#39;getConfig&#39;, function () &#123;&#10;&#10;    it(&#39;should return an object&#39;, function () &#123;&#10;        getConfig().then(function (config) &#123;&#10;            config.should.be.Object;&#10;        &#125;);&#10;    &#125;);&#10;&#10;    it(&#39;should return config with valid port&#39;, function () &#123;&#10;        getConfig().then(function (config) &#123;&#10;            config.should.have.property(&#39;port&#39;).which.is.Number;&#10;        &#125;);&#10;    &#125;);&#10;&#10;    it(&#39;should return config with valid host&#39;, function () &#123;&#10;        getConfig().then(function (config) &#123;&#10;            config.should.have.property(&#39;host&#39;).which.is.String;&#10;        &#125;);&#10;    &#125;);&#10;&#10;&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="přísliby-asynchronní-kód">Přísliby = asynchronní kód</h2>
<p>Všechny tři testy nyní projdou. Jdeme ale dále: co by se stalo, kdybychom napsali test, který neprojde? Dejme tomu, že se rozhodneme přejmenovat vlastnost <code>host</code> na <code>hostname</code>. A protože se třeba řídíme TDD, jako první přepíšeme testy a až pak kód:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it(&#39;should return config with valid host&#39;, function () &#123;&#10;    getConfig().then(function (config) &#123;&#10;        config.should.have.property(&#39;hostname&#39;).which.is.String;&#10;    &#125;);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Testy spustíme a …</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Possibly unhandled AssertionError: expected &#123; port: 1234, host: &#39;localhost&#39; &#125; to have property &#39;hostname&#39;&#10;...&#10;&#10;3 passing (19ms)</span><br></pre></td></tr></table></figure>
<p>No… to není úplně výsledek, který bychom čekali, že? Problém je v tom, že při používání příslibů se pohybujeme v asynchronním kódu. Aserce <code>config.should.have.property('hostname').which.is.String;</code> nám tak sice vyhodí výjimku, jenže ji vyhodí v asynchronně prováděném kódu a tato výjimka se tak nebude propagovat zpět do testu Mochy a zůstane ztracena někde uprostřed ničeho. Ona hláška <code>Possibly unhandled AssertionError</code> už je jen takový zoufalý pokus Bluebirdu upozornit nás na to, že se někde stala chyba, na kterou nikdo nikde nereagoval.</p>
<p>Novější verze Mocha umí s přísliby pracovat, takže úplně nejvíc nejjednodušší cesta jak test opravit je vrátit příslib z funkce pomocí <code>return</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it(&#39;should return config with valid host&#39;, function () &#123;&#10;    return getConfig().then(function (config) &#123;&#10;        config.should.have.property(&#39;hostname&#39;).which.is.String;&#10;    &#125;);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Testovací funkce nyní vrací příslib, se kterým dále v testu pracujeme. Aserce vyhodí výjimku, tu odchytne příslibová knihovna a nastaví příslib jako rejected. Mocha to pozná, vytáhne si chybu, zobrazí ji a nastaví test jako <em>failed</em>. Jednoduché jako facka.</p>
<p>Výborně, všechny testy takto přepíšeme:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe(&#39;getConfig&#39;, function () &#123;&#10;&#10;    it(&#39;should return an object&#39;, function () &#123;&#10;        return getConfig().then(function (config) &#123;&#10;            config.should.be.Object;&#10;        &#125;);&#10;    &#125;);&#10;&#10;    it(&#39;should return config with valid port&#39;, function () &#123;&#10;        return getConfig().then(function (config) &#123;&#10;            config.should.have.property(&#39;port&#39;).which.is.Number;&#10;        &#125;);&#10;    &#125;);&#10;&#10;    it(&#39;should return config with valid host&#39;, function () &#123;&#10;        return getConfig().then(function (config) &#123;&#10;            config.should.have.property(&#39;hostname&#39;).which.is.String;&#10;        &#125;);&#10;    &#125;);&#10;&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Pokud nyní spustíme testy, získáme správný výstup:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 passing (14ms)&#10;1 failing&#10;&#10;1) getConfig should return config with valid host:&#10;   AssertionError: expected &#123; port: 1234, host: &#39;localhost&#39; &#125; to have property &#39;hostname&#39;</span><br></pre></td></tr></table></figure>
<p>Protože jsme ještě nepřepsali produkční kód, tak nám jeden test padá a Mocha nám to hezky oznamuje.</p>
<h2 id="nechybí-nám-tam-nějaké-done">Nechybí nám tam nějaké <code>done</code>?</h2>
<p>Z klasických asynchronních testů, které používají callbacky, jste asi zvyklí na to, že testovací funkce má ještě parametr <code>done</code>, což je funkce, která se volá, když všechny testy úspěšně doběhnou.</p>
<p>Co kdybychom naši funkci getConfig přepsali takto?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var getConfig = function () &#123;&#10;    return new Promise(function(resolve, reject) &#123;&#10;        setTimeout(function() &#123;&#10;            resolve(&#123;&#10;                port: 1234,&#10;                hostname: &#34;localhost&#34;&#10;            &#125;);&#10;        &#125;, 1000);&#10;    &#125;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Tj. funkce by sice vrátila příslib, který by se resolvnul na náš <strong>správný</strong> objekt (je tam už <code>hostname</code> místo <code>host</code>), ale vrátila by nám až za jednu sekundu. Jasně, v unit testech bychom nikdy neměli volat pravý <code>setTimeout</code>, který bude čekat sekundu nebo více, ale jen tak pro legraci … co by nám teď řekly testy?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 passing (3s)</span><br></pre></td></tr></table></figure>
<p>Mocha je dost chytrá na to, aby věděla, že má počkat, než bude příslib resolvnutý nebo rejectnutý a ve chvíli, kdy jedno z toho nastane, tak testování ukončí. Alespoň nová verze Mochy, jestli máte nějakou starší, tak to nebude fungovat. Žádný parametr <code>done</code> tak do testovací funkce přidávat nemusíme.</p>
<h2 id="finální-řešení-chai-as-promised">Finální řešení: <em>Chai as promised</em></h2>
<p>Existuje jedna velice šikovná knihovna, která umožňuje dále zjednodušit psaní příslibových testů: <a href="https://github.com/domenic/chai-as-promised/" target="_blank" rel="external">chai as promised</a>. K této knihovně budeme ještě potřebovat samotnou knihovnu <code>chai</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install chai chai-as-promised</span><br></pre></td></tr></table></figure>
<p>V testovacím souboru pak obě knihovny requirneme a nastavíme takto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var chai = require(&#34;chai&#34;);&#10;chai.use(require(&#34;chai-as-promised&#34;));&#10;var expect = chai.expect</span><br></pre></td></tr></table></figure>
<p>Na prvních dvou řádcích taháme testovací knihovnu <code>chai</code> a říkáme, aby používala plugin <code>chai-as-promised</code>. Na třetím řádku z Čaje vytáhneme funkci <code>expect</code>, kterou budeme dále používat pro testování. Vytáhnul jsem <code>expect</code> jednak proto, že ho mám nejraději a jednak proto, ať to odliším od předchozího <code>should</code>, který jsem používal z Mochy. Nicméně i Čaj umožňuje používat <code>should</code>.</p>
<p>Tím, že jsme použili plugin <code>chai-as-promised</code>, můžeme psát testy za pomocí vlastnosti <code>eventually</code>. V podstatě jen na vhodné místo přidáme vlastnost <code>eventually</code> a jinak napíšeme test jak jsme zvyklí. Například tento kód</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect([<span class="number">1</span>, <span class="number">2</span>]).to.have.length(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>testuje, jestli má dané pole délku dva. Pokud bychom nepracovali s polem, ale s příslibem, který se teprve vyhodnotí na pole o délce dva, napsali bychom:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(<span class="built_in">Promise</span>.resolve([<span class="number">1</span>, <span class="number">2</span>])).to.eventually.have.length(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>Přidali jsme vlastnost <code>eventually</code>, čímž říkáme, že v expectu je příslib, který by se měl jednou vyhodnotit na pole o délce dva. Eventually samo se postará o vyhodnocení příslibu, my se už o nic starat nemusíme. Naše testy bychom tak přepsali úplně stejně:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe(&#39;getConfig&#39;, function () &#123;&#10;    it(&#39;should return an object&#39;, function () &#123;&#10;        return expect(getConfig()).to.eventually.be.an(&#34;Object&#34;);&#10;    &#125;);&#10;&#10;    it(&#39;should return config with valid port&#39;, function () &#123;&#10;        return expect(getConfig()).to.eventually.have.property(&#39;port&#39;).that.is.a(&#39;Number&#39;);&#10;    &#125;);&#10;&#10;    it(&#39;should return config with valid hostname&#39;, function () &#123;&#10;        return expect(getConfig()).to.eventually.have.property(&#39;hostname&#39;).that.is.a(&#39;String&#39;);&#10;    &#125;);&#10;&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>Pokud spustíme tyto testy, tak správně spadnou na tom, že naše funkce getConfig vytváří config s vlastností <code>host</code>, ne <code>hostname</code>. Pokud tuto chybu opravíme, testy správně projdou.</p>
<p>No není to nádhera? Testy jsou krásně krátké a funkční, co víc chtít.</p>
<p><a href="https://github.com/domenic/chai-as-promised/" target="_blank" rel="external">Chai as promised</a> toho samozřejmě umí mnohem více, podívejte se do dokumentace. Můžete například snadno testovat, jestli je příslib rejectnutý, nebo je fulfilled a podobně.</p>
<p>Toť vše, veselé testování. Čáj!</p>
<!-- p="A jestli vás článek opravdu zaujal, "--><!--  a(href="http://www.ibillboard.com/cs/spolecnost/spolecnost/kariera/202-vyvojar-nodejs-javascript")="tak pojďte pracovat k nám do firmy!"--><!--  =" Podobných problémů řešíme mraky." -->
<div class="relatedBox"><div class="relatedArticlesBox"><h2 id="relatedArticles">Související články:</h2><ol><li><a href="/prisliby-v-javascriptu/">Přísliby v JavaScriptu</a></li></ol></div></div><div class="articleTags"><strong><a href="/tags/node.js">#node.js</a></strong></div></div></article><div style="text-align: right"><div class="fb-like" data-layout="button_count" data-action="like" data-show-faces="true" data-share="true" style="margin-top: 10px; height: 30px"></div></div><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/node-js/" class="post__tag__link">node.js</a></li></ul><a href="/jak-v-javascriptu-testovat-funkce-s-prisliby/#disqus_thread" class="post__foot-link u-fr">Komentáře</a></footer></main><footer class="foot"><div class="foot-copy u-fl"><a href="/">Programio</a> píše <a href="http://www.havrlant.cz/">Lukáš Havrlant</a></div><menu class="page-menu u-fr"><li class="page-menu__item"><a title="Previous" href="/linear-counting/" class="page-menu__link icon-arrow-left"></a></li><li class="page-menu__item"><a title="Next" href="/jak-pracovat-s-obrazky-v-hexoio/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],
j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})
(document,"script","programio","embed");
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-1559810-13');ga('send','pageview');
</script><div id="fb-root"></div><script>(function(d, s, id) {
var js, fjs = d.getElementsByTagName(s)[0];
if (d.getElementById(id)) return;
js = d.createElement(s); js.id = id;
js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&appId=166268190106534&version=v2.0";
fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script></body></html>