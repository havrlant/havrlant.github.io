<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="Programio" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><title>HyperLogLog: Jak odhadnout počet unikátních hodnot - Programio</title><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro"><link rel="stylesheet" href="/css/main.css" type="text/css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"> <a href="/">Programio</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Domů</a></li><li class="head-nav__item"><a href="/archives" class="head-nav__link">Archiv</a></li><li class="head-nav__item"><a href="http://www.havrlant.cz/" class="head-nav__link">O autorovi</a></li><li class="head-nav__item"><a href="/rss.xml" class="head-nav__link">RSS</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2014-12-01T18:16:17.000Z" class="post__time">1. 12. 2014</time><h1 class="post__title"><a href="/hyperloglog/">HyperLogLog: Jak odhadnout počet unikátních hodnot</a></h1></header><div class="post__main echo"><p>Série o algoritmech na odhadování počtu unikátních hodnot v multimnožině pokračuje článkem o <em>state of the art</em> algoritmu <strong>HyperLogLog</strong>. Nicméně veškeré myšlenky, které stojí za tímto algoritmem vychází z dříve popsaného <a href="/loglog">LogLogu</a>, takže pokud chcete číst dál, ujistěte se, že znáte dobře LogLog. </p>
<p>Algoritmus LogLog měl dva hlavní problémy: </p>
<h2 id="Outliery">Outliery</h2><p>Výsledný odhad LogLogu je velmi náchylný na outliery, hodnoty, které jsou velmi vzdálené od ostatních hodnot. Typicky se totiž stává, že většina maximálních délek nulových prefixů pro každou skupinu je přibližně stejná, například se pohybuje mezi 12 a 15, ale pak buch – a jeden nulový suffix má délku 27. Tenhle velký rozdíl udělá nepořádek ve výsledném odhadu počtu unikátů, protože klasický aritmetický průměr si s tím moc dobře neporadí. V podstatě zafungoval stejný princip, jako když pár top manažerů a ředitelů zvedne průměrnou mzdu v republice svými vysokými mzdami. </p>
<p>Autoři algoritmu se to snažili řešit tím, že se outlierů zbavovali a do průměru nezapočítali několik nejvyšších maxim, ale to nebylo příliš dobré řešení. Později zkusili jiný postup – místo aritmetického průměru použili průměr <a href="http://cs.wikipedia.org/wiki/Harmonický_průměr" target="_blank" rel="external">harmonický</a>, který má daleko lepší vlastnosti v případě, kdy máme hodnoty, které jsou vzdálené od průměru. </p>
<h2 id="Velmi_špatné_výsledky_pro_malé_kardinality">Velmi špatné výsledky pro malé kardinality</h2><p>LogLog má příšerné výsledky, má-li odhadovat kardinalitu malých multimnožin. Pokud máme v multimnožině několik málo unikátních prvků, vrátí nám LogLog nesmyslně velký odhad. Autoři to vyřešili fikaně – v případě, kdy máme na vstupu multimnožinu s nízkou kardinalitou, nepoužije se algoritmus LogLog, ale použije se úplně jiný algoritmus, a sice starý známý <a href="/linear-counting/">Linear counting</a>. No jo, ale jak poznáme, že máme na vstupu multimnožinu s malou kardinalitou, když kardinalitu právě neznáme? </p>
<p>Necháme LogLogem odhadnout počet unikátních prvků a když zjistíme, že tento odhad je <em>relativně nízký</em>, odhad zahodíme a spočítáme ho znovu algoritmem Linear counting. V rychlosti si připomeneme, jak Linear counting funguje. Na začátku alokujeme nulové (bitové) pole o nějaké předem dané velikosti, typicky mocnina dvojky. Projdeme všechny prvky multimnožiny, spočítáme jejich hash a ten převedeme na celé číslo <code>i</code> z intervalu 0 až délka pole minus 1. Na index <code>i</code> pak v poli uložíme jedničku. Nakonec spočítáme počet nul a jedniček v poli a pomocí  <a href="/linear-counting">jednoduchého vzorce</a> odhadneme kardinalitu.</p>
<p>Algoritmus LogLog ale žádné bitové pole, do kterého by si “ukládal” vypočítané hashe, nepoužívá. Místo toho používá pole, ve kterém si uchovává maximální délky suffixů. Pole může vypadat například takto:</p>
<pre><code>[<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>]
</code></pre><p>přičemž každé číslo označuje maximální délku nulového suffixu v dané skupině vypočítaných hashů. Nenulová hodnota na <code>i</code>-té pozici pak ale nutně znamená, že mezi hodnotami v multimnožině existuje prvek, jehož (tříbitový) hash je roven <code>i</code>. Jinými slovy, toto pole můžeme převést na bitové pole pro linear counting tak, že nuly ponecháme a jakékoliv kladné číslo převedeme na jedničku. Z předchozího pole bychom tak dostali bitové pole:</p>
<pre><code>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]
</code></pre><p>Nyní můžeme aplikovat algoritmus Linear counting a odhadnout kardinalitu pomocí něj. </p>
<p>Má to ovšem jeden háček. My do pole ukládáme maximální nulový suffix, jenomže co když v nějaké skupině hodnot končí všechny hashe na jedničku? Pokud například použijeme poslední tři bity jako identifikátor skupiny, do které hash patří, pak by délka nulového suffixu tohoto hashe “01001100” byla nula – protože vektor “01001” končí na jedničku. Do pole maxim bychom tak na index 4 (100<sub>2</sub>=4<sub>10</sub>) uložili nulu. V algoritmu linear counting by se to ale projevilo tak, že jsme nenašeli hodnotu, která by měla za hash čtyřku, což není pravda. </p>
<p>Proto upravíme algoritmus tak, aby neukládal do pole maxim délku nejdelšího nulového suffixu, ale aby ukládal index “první jedničky zprava” (pro pořádek – indexujeme od jedničky), což je totéž, jako bychom k délce nulového suffixu přičetli jedničku. Tím dosáhneme toho, že nula na indexu <code>i</code> znamená, že žádná hodnota nemá hash rovnou <code>i</code> a takové pole pak můžeme použít pro linear counting. </p>
<h2 id="Implementace_HyperLogLogu">Implementace HyperLogLogu</h2><p>Hezky postupně:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alpha</span><span class="params">(num_buckets)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0.7213</span> / (<span class="number">1</span> + <span class="number">1.079</span> / num_buckets))</span><br></pre></td></tr></table></figure>
<p>Funkce <code>alpha</code> vrací korekci pro vypočítaný odhad, to už známe z minula, pouze v případně HyperLogLogu má alpha jinou hodnotu v závislosti na počtu skupin. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trailing_zeroes</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    zeroes = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (number &amp; <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">        zeroes += <span class="number">1</span></span><br><span class="line">        number = number &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> zeroes</span><br></pre></td></tr></table></figure>
<p>Funkce, která vrací počet nulových bitů na konci čísla.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_maxims</span><span class="params">(values, k)</span>:</span></span><br><span class="line">    num_buckets = <span class="number">2</span> ** k  </span><br><span class="line">    max_zeroes = [<span class="number">0</span>] * num_buckets</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">        h = hash(value)</span><br><span class="line">        bucket_index = h &amp; (num_buckets - <span class="number">1</span>)</span><br><span class="line">        bucket_hash = h &gt;&gt; k</span><br><span class="line">        num_zeros = trailing_zeroes(bucket_hash) + <span class="number">1</span></span><br><span class="line">        max_zeroes[bucket_index] = max(max_zeroes[bucket_index], num_zeros)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_zeroes</span><br></pre></td></tr></table></figure>
<p>Funkce, která projde všechny hodnoty, rozdělí je <code>num_buckets</code> skupin a pro každou skupinu vypočítá index první jedničky zprava (délku maximálního nulového suffixu plus jedna).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_counting</span><span class="params">(number_of_ones, num_buckets)</span>:</span></span><br><span class="line">    number_of_zeros = num_buckets - number_of_ones</span><br><span class="line">    Z = float(number_of_zeros) / num_buckets</span><br><span class="line">    p = (-num_buckets) * log(Z)</span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>
<p>Lehce upravená funkce pro výpočet algoritmu <a href="linear-counting">Linear counting</a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">estimate_cardinality</span><span class="params">(values, k)</span>:</span> </span><br><span class="line">    num_buckets = <span class="number">2</span> ** k   </span><br><span class="line">    max_zeroes = count_maxims(values, k)</span><br><span class="line">    estimate = float(alpha(num_buckets) * (num_buckets**<span class="number">2</span>)) / sum(<span class="number">2</span>**(-r) <span class="keyword">for</span> r <span class="keyword">in</span> max_zeroes)</span><br><span class="line">    number_of_ones = sum(<span class="number">1</span> <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> max_zeroes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (estimate &lt;= <span class="number">2.5</span> * num_buckets) <span class="keyword">and</span> (number_of_ones &lt; num_buckets):</span><br><span class="line">        <span class="keyword">return</span> linear_counting(number_of_ones, num_buckets)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> estimate</span><br></pre></td></tr></table></figure>
<p>Hlavní funkce, která to vše dává dohromady. Nejdříve vypočte odhad pomocí upraveného LogLogu, místo aritmetického průměru použije na čtvrtém řádku harmonický průměr a nakonec aplikuje korekci v podobě Linear countingu, pokud je vypočítaný odhad menší než 2,5 násobek počtu skupin (v tuto chvíli očekáváme, že bude standardní odhad LogLogu horší než kdyby se použil Linear counting) a pokud je v poli maxim alespoň jedna nula (pole, ve kterém jsou samé jedničky nemůžeme v Linear countingu použít, viz <a href="/linear-counting">předchozí článek</a>). A jaké jsou výsledky HyperLogLogu? </p>
<p>Spustíme testovací kód, který nám odhadne kardinalitu množin, které mají postupně kardinalitu 10, 100, …, 1 000 000:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">    num_values = <span class="number">10</span>**x</span><br><span class="line">    values = (str(uuid4()) <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(num_values))</span><br><span class="line">    cardinality = estimate_cardinality(values, <span class="number">14</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Cardinality: %s, relative error: %s"</span> % (cardinality, num_values / cardinality)</span><br></pre></td></tr></table></figure>
<p>Výsledky:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cardinality: 10.0030530001, relative error: 0.999694793165&#10;Cardinality: 100.306423257, relative error: 0.996945128268&#10;Cardinality: 1003.0892434, relative error: 0.99692027063&#10;Cardinality: 10013.1348931, relative error: 0.998688233677&#10;Cardinality: 100520.045562, relative error: 0.994826449206&#10;Cardinality: 998088.420332, relative error: 1.0019152408</span><br></pre></td></tr></table></figure>
<p>Vidíme, že výsledky jsou vždy odchýlené od správného výsledky o méně než procento. A to je dobré! </p>
<h2 id="Další_vylepšení_HyperLogLogu">Další vylepšení HyperLogLogu</h2><p>HyperLogLog se dočkal několika dalších zajímavých vylepšení. Jedním ze zbývajících problémů je <em>vysoká paměťová náročnost</em>. To zní dost divně, když jsme si minule paměťovou náročnost vychvalovali do nebes a spočítali jsme si, že na uložení pole maxim nám stačí 768 bajtů. Jenomže problém nastává, pokud chcete počítat kardinalitu ne jedné obrovské multimnožiny, ale paralelně několika milionů malých multimnožin nebo pokud si tyto vypočítané pole maxim chcete uchovávat v databázi na nějaké pozdějí čachry machry. </p>
<p>Pokud bychom například počítali současně kardinalitu jedné miliardy multimnožin, potřebovali bychom při současné implementaci 1 000 000 000 krát 768 bajtů, což je 768 GB. Na jednu stranu to není špatné … ale na druhou stranu jsme schopni HyperLogLog implementovat lépe. </p>
<h3 id="Sparse_reprezentace">Sparse reprezentace</h3><p>Představme si, že nastavíme <code>k=12</code>, tj. použijeme 12 bitů pro identifikaci skupin a dostaneme tudíž 2<sup>12</sup> různých skupin hashů. Na začátku algoritmu musíme alokovat pole o délce 4096 (viz řádek 3 funkce <code>count_maxims</code>). A dejme tomu, že naše multimnožina má tři různé prvky. To znamená, že do pole na tři různá místa nastavíme nějakou hodnotu a zbylých 4093 hodnot v poli zůstane nulových, zbylých 4093 jsme zkrátka nijak nepoužili. To není moc efektivní, že? </p>
<p>Abychom se vyhnuli tomu, že budeme mít pole, které bude z větší částí nulové a nepoužité, ale které přesto zabírá cenný kus paměti, můžeme na začátku hodnoty ukládat jako dvojice <code>[index, hodnota]</code>. Příklad pro lepší pochopení. Toto pole</p>
<pre><code>[<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]
</code></pre><p>můžeme daleko paměťově efektivněji reprezentovat jako dvě dvojice:</p>
<pre><code>[<span class="number">0</span>, <span class="number">7</span>], [<span class="number">4</span>, <span class="number">12</span>]
</code></pre><p>Místo toho, abychom měli v paměti alokovanou hromadu nevyužitého místo, můžeme postupně alokovat jen to místo, které opravdu potřebujeme. Této reprezentaci říkáme <em>sparse</em>. Nicméně v jednu chvíli by takto reprezentace byla paměťově náročnější než právě uložení do pole – pak můžeme sparse reprezentaci převézt na klasické pole bez ztráty informace. </p>
<h3 id="Offsety">Offsety</h3><p>Praxe ukázala, že se všechny hodnoty v poli jsou <em>zhruba stejné</em>. Pole maxim běžně vypadá například takto:</p>
<pre><code>[<span class="number">12</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">12</span>, ...,  <span class="number">13</span>, <span class="number">14</span>, <span class="number">11</span>]
</code></pre><p>Všechny hodnoty se pohybují někde kolem čísla 13. Další ze strategií, jak zmenšit velikost takového pole, je odečíst od každého prvku nějakou fixní hodnotu a tu si zapamatovat. Můžeme odečíst například osmičku:</p>
<pre><code>[<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, ..., <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>]
</code></pre><p>V tuto chvíli spotřebuje každá hodnota v poli menší množství v paměti – v prvním poli potřebujeme ukládat čísla od 0 do 15, na což potřebujeme 4 bity, zatímco na druhé pole nám stačí 3 bity, protože ukládáme jen čísla od 0 do 7. Samozřejmě to předpokládá implementaci pole na úrovni jednotlivých bitů. Ve chvíli, kdy budeme chtít hodnoty z pole přečíst, musíme k nim  zpátky přičíst poznamenanou hodnotu. </p>
<p>…a hromada dalších vylepšení. Výzkum v této oblasti stále ještě běží, takže se jistě můžeme těšit na další zajímavé nápady. My si příště povíme něco o sjednocení a průniku HyperLogLog vektorů a někdy v blízké budoucnosti si povíme, proč se nám může hodit ukládat si miliardy HyperLogLog vektorů. </p>
<h1 id="Odkazy_a_zdroje">Odkazy a zdroje</h1><ul>
<li>Celou mou implementaci si můžete prohlédnout na <a href="https://gist.github.com/havrlant/96f1126cebfe6991fa09" target="_blank" rel="external">GitHubu</a>.</li>
<li><a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf" target="_blank" rel="external">HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm [PDF]</a> – původní článek, ve kterém byl představen HyperLogLog. </li>
<li><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/pubs/archive/40671.pdf" target="_blank" rel="external">HyperLogLog in Practice: Algorithmic Engineering of a State of The Art Cardinality Estimation Algorithm [PDF]</a> – Vylepšená verze původního HyperLogLogu, například o zmíněnou sparse reprezentaci. </li>
</ul>
<div class="relatedBox"><div class="relatedArticlesBox"><h2 id="relatedArticles">Související články:</h2><ol><li><a href="/linear-counting/">Linear Counting: Jak odhadnout počet unikátních hodnot</a></li><li><a href="/min-value/">Min Value: Jak odhadnout počet unikátních hodnot</a></li><li><a href="/loglog/">LogLog: Jak odhadnout počet unikátních hodnot</a></li><li><a href="/sjednoceni-hyperloglogu/">Sjednocení Hyperloglogu</a></li></ol></div></div><div class="articleTags"><strong><a href="/tags/algoritmy">#algoritmy</a></strong>, <strong><a href="/tags/hyperloglog">#hyperloglog</a></strong></div></div></article><div style="text-align: right"><div class="fb-like" data-layout="button_count" data-action="like" data-show-faces="true" data-share="true" style="margin-top: 10px; height: 30px"></div></div><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/algoritmy/" class="post__tag__link">algoritmy</a></li><li class="post__tag__item"><a href="/tags/hyperloglog/" class="post__tag__link">hyperloglog</a></li></ul><a href="/hyperloglog/#disqus_thread" class="post__foot-link u-fr">Komentáře</a></footer></main><footer class="foot"><div class="foot-copy u-fl"><a href="/">Programio</a> píše <a href="http://www.havrlant.cz/">Lukáš Havrlant</a></div><menu class="page-menu u-fr"><li class="page-menu__item"><a title="Previous" href="/jak-vytvarim-interni-odkazy/" class="page-menu__link icon-arrow-left"></a></li><li class="page-menu__item"><a title="Next" href="/loglog/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],
j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})
(document,"script","programio","embed");
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-1559810-13');ga('send','pageview');
</script><div id="fb-root"></div><script>(function(d, s, id) {
var js, fjs = d.getElementsByTagName(s)[0];
if (d.getElementById(id)) return;
js = d.createElement(s); js.id = id;
js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&appId=166268190106534&version=v2.0";
fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script></body></html>