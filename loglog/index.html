<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="Programio" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><title>LogLog: Jak odhadnout počet unikátních hodnot - Programio</title><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro"><link rel="stylesheet" href="/css/main.css" type="text/css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"> <a href="/">Programio</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Domů</a></li><li class="head-nav__item"><a href="/archives" class="head-nav__link">Archiv</a></li><li class="head-nav__item"><a href="http://www.havrlant.cz/" class="head-nav__link">O autorovi</a></li><li class="head-nav__item"><a href="/rss.xml" class="head-nav__link">RSS</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2014-10-29T18:52:29.000Z" class="post__time">29. 10. 2014</time><h1 class="post__title"><a href="/loglog/">LogLog: Jak odhadnout počet unikátních hodnot</a></h1></header><div class="post__main echo"><p>Po předchozích dílech o <a href="/linear-counting/">Linear Countingu</a> a <a href="/min-value/">Min Value</a> se konečně dostáváme ke skoro nejvíc nejlepšímu pravděpodobnostnímu algoritmu na odhadování počtu unikátních hodnot v sadě dat, LogLogu. Lepší už je jen jeho bratříček HyperLogLog, který z LogLogu vychází, ale o něm zase příště.</p>
<p>Zopakujeme si zadání problému. Na vstupu máme nějakou sadu dat/multimnožinu, například nějaké pole/generátor idéček. V tomto poli jsou nějaké hodnoty vícekrát a my chceme spočítat počet unikátních hodnot v tomto poli. Tomuto počtu budeme říkat kardinalita. Očekáváme, že tato kardinalita bude opravdu velká, jinak můžeme použít konvenční algoritmy.</p>
<h2 id="Myšlenka_LogLog_algoritmu">Myšlenka LogLog algoritmu</h2><p>Představme si, že máme sadu binárních vektorů. Nelekejte se, například toto 0001011001001100 je binární vektor délky 16. Dejme tomu, že máme binární vektory délky 32 a že jich máme celkem jeden milion, všechny <strong>zcela náhodně vygenerované</strong>. Kolik vektorů bude končit číslem nula? </p>
<p>To samozřejmě nemůžeme vědět přesně, ale pokud jsme ty vektory opravdu generovali náhodně, měla by jich nulou končit přibližně polovina, tj. 500 tisíc. Kolik vektorů bude končit na 00? Čtvrtina. Na 000? Osmina. A tak dále. Znázornit to můžeme zhruba takto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vzor vektoru      pod&#237;l mezi v&#353;emi vektory&#10;...xxxxxx0        50 %&#10;...xxxxx00        25 %&#10;...xxxx000        12,5 %&#10;...xxx0000        6,25 %&#10;     ...          ...</span><br></pre></td></tr></table></figure>
<p>Pokud se zeptáme na suffix (suffix je řetězec, kterým končí jiný řetězec – opak prefixu) o délce <code>d</code>, očekáváme, že nalezneme <code>v</code> vektorů, které tímto suffixem končí. Hodnotu <code>v</code> vypočteme jako:</p>
<p><img src="/loglog/pocetvektoru.svg" alt=""></p>
<p>kde <code>N</code> je počet všech vektorů v sadě. Suffix délky 3 (například …010) by se měl vyskytovat v <code>1/2^3 N = 1/8 N</code> vektorů, tj. 12,5 % ze všech vektorů. </p>
<p>Teď provedeme takový malý mindfuck. Mějme multimnožinu 1024 unikátních vektorů. Kolik vektorů by mělo končit suffixem 0000000000? (deset nul) Dosadíme do vzorce a vyjde nám </p>
<p><img src="/loglog/loglog.svg" alt=""></p>
<p>Huh, jeden! V tisíci náhodně vygenerovaných binárních vektorů by měl být právě jeden vektor, který končí deseti nulami. A jak tuhle informaci použít k tomu, abychom odhadli počet unikátních prvků? My totiž můžeme postupovat opačně. Co když projdeme všechny binární vektory, které máme na vstupu a zjistíme, že v sadě existuje jediný vektor, který končí deseti nulami? Pak přece můžeme odhadnout, že v sadě bylo 1024 vektorů! </p>
<p><img src="/loglog/mindblown.gif" alt=""></p>
<h2 id="Zobecňujeme_a_sestavujeme_algoritmus">Zobecňujeme a sestavujeme algoritmus</h2><p>Cílem by mělo být najít takový suffix, který je obsažen pouze v jediném vektoru, přičemž tento suffix je co možná nejkratší. To jde ovšem jen velmi těžko, protože abychom opravdu nalezli takový vektor, museli bychom si všechny suffixy ukládat, což nechceme, protože by to zabralo příliš paměti. Místo toho se spokojíme s tím, že budeme hledat nejdelší posloupnost nul na konci vektoru. </p>
<p>Projdeme tedy všechny vektory, u každého vektoru spočítáme, kolik nul obsahuje na konci a v jedné proměnné si budeme uchovávat maximum z těchto hodnot. Až projdeme všechny vektory, budeme znát délku nejdelšího suffixu, který je tvořen jen nulami. Tuto délku označujeme písmenem <code>d</code>. Nyní upravíme předchozí vzorec tak, abychom osamostatnili proměnnou <code>N</code>, tj. aby to byl výstup algoritmu, ne vstup. Přitom místo <code>v</code> můžeme dosadit jedna, protože očekáváme, že nalezneme právě jeden takový vektor, tj. očekáváme, že bude platit <code>v=1</code>. </p>
<p><img src="/images/hyperloglog.svg" alt=""></p>
<p>Najdeme-li tak délku <code>d</code> nejdelšího nulového suffixu, odhadneme kardinalitu pomocí  vzorce <code>N=2<sup>d</sup></code>. </p>
<h2 id="Jak_získat_náhodné_binární_vektory?">Jak získat náhodné binární vektory?</h2><p>S náhodnými binárními vektory už nám algoritmus funguje, ale jak tento postup aplikavat na reálná data? Jako obvykle, i zde použijeme nějakou <a href="http://en.wikipedia.org/wiki/MurmurHash" target="_blank" rel="external">vhodnou hashovací funkci</a>. Máme-li na vstupu sadu dat, například idéčka (stringy), tak je nejprve zahashujeme. Výstupem <code>n</code>-bitové hashovací funkce je <code>n</code> bitů, které z praktického pohledu vypadají jako náhodně vygenerované binární vektory. </p>
<p>V tuto chvíli už můžeme sepsat náš algoritmus:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def trailing_zeroes(number):&#10;    if number == 0: &#10;        return 0&#10;&#10;    zeroes = 0&#10;    while (number &#38; 1) == 0:&#10;        zeroes += 1&#10;        number = number &#62;&#62; 1&#10;    return zeroes&#10;&#10;def count_unique(values):&#10;    max_zero_suffix_length = 0&#10;    for value in values:&#10;        zeroes_length = trailing_zeroes(hash(value))&#10;        max_zero_suffix_length = max(zeros_length, max_zero_suffix_length)&#10;    return 2 ** max_zero_suffix_length</span><br></pre></td></tr></table></figure>
<p>Funkce <code>trailing_zeroes</code> vrací počet nul na konci čísla. Jak to dělá? Jestli jste to nepochopili z kódu, tak se radši ani neptejte. A jakou úspěšnost funkce má? Pro množinu, která obsahovala sto tisíc unikátních prvků vrátila funkce odhad 524 288. </p>
<p>No…</p>
<p>Tak jako není to úplně dobré, že? Ale to nevadí! Zkusíme algoritmus vylepšit úplně stejně, jako předchozí <a href="/min-value/">Min Value</a>. Rozdělíme vstupní data na několik disjunktních skupin a pro každou skupinu spočítáme maximální nulový suffix a nakonec spočítáme průměrnou délku nulového suffixu a ten použijeme pro odhad počtu unikátů. </p>
<p>Můžeme si například říci, že poslední dva bity každého vektoru budou určovat číslo skupiny, do které vektor patří. Těchto šest vektorů</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1101110111111011             1110110010100101&#10;1011001111110010             1111101100000011&#10;1010101000100000             0110010110011000</span><br></pre></td></tr></table></figure>
<p>můžeme rozdělit do čtyř skupin podle toho, jakou mají koncovku:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00                 |  01                |   10                 |  11&#10;---------------------------------------------------------------------------------&#10;10101010001000&#60;span style=&#34;color: red&#34;&#62;00&#60;/span&#62;   |  11101100101001&#60;span style=&#34;color: red&#34;&#62;01&#60;/span&#62;  |  10110011111100&#60;span style=&#34;color: red&#34;&#62;10&#60;/span&#62;    | 11011101111110&#60;span style=&#34;color: red&#34;&#62;11&#60;/span&#62;&#10;01100101100110&#60;span style=&#34;color: red&#34;&#62;00&#60;/span&#62;   |                    |                      | 11111011000000&#60;span style=&#34;color: red&#34;&#62;11&#60;/span&#62;</span><br></pre></td></tr></table></figure>
<p>Dále spočítáme délku nejdelšího nulového suffixu v každém vektoru, přitom ale přeskočíme ty bity, které jsme použili jako číslo skupiny. Nulové “suffixy” označíme zeleně: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00                 |  01                |   10                 |  11&#10;---------------------------------------------------------------------------------&#10;10101010001&#60;span style=&#34;color: green&#34;&#62;000&#60;/span&#62;&#60;span style=&#34;color: red&#34;&#62;00&#60;/span&#62;   |  11101100101001&#60;span style=&#34;color: red&#34;&#62;01&#60;/span&#62;  |  101100111111&#60;span style=&#34;color: green&#34;&#62;00&#60;/span&#62;&#60;span style=&#34;color: red&#34;&#62;10&#60;/span&#62;    | 1101110111111&#60;span style=&#34;color: green&#34;&#62;0&#60;/span&#62;&#60;span style=&#34;color: red&#34;&#62;11&#60;/span&#62;&#10;0110010110011&#60;span style=&#34;color: green&#34;&#62;0&#60;/span&#62;&#60;span style=&#34;color: red&#34;&#62;00&#60;/span&#62;   |                    |                      | 11111011&#60;span style=&#34;color: green&#34;&#62;000000&#60;/span&#62;&#60;span style=&#34;color: red&#34;&#62;11&#60;/span&#62;&#10;---------------------------------------------------------------------------------&#10;3                  |  0                 |   2                  |  6</span><br></pre></td></tr></table></figure>
<p>V posledním řádku je délka nejdelšího nulového suffixu z dané skupiny. Z těchto suffixů můžeme spočítat <a href="http://www.matematika.cz/prumer" target="_blank" rel="external">aritmetický průměr</a>, který nám vyjde 2,75. Hodnotu dosadíme do vzorce a vyjde nám <code>2^2,75≈6,727</code>. Získáme průměrný počet unikátních prvků v každé skupině. Což samozřejmě vůbec nesedí, ale tím se netrapme, pro malé množiny dává algoritmus LogLog příšerné výsledky.</p>
<p>Abychom odhadli kardinalitu celé množiny, musíme ještě tuto hodnotu vynásobit počtem skupin: <code>6,727 · 4 = 26,908</code>. Algoritmus spočítal, že v sadě je přibližně 27 unikátních hodnot. Bylo jich tam šest, takže je to úplně mimo, ale to teď fakt nevadí. </p>
<h2 id="Implementace_algoritmu">Implementace algoritmu</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trailing_zeroes</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    zeroes = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (number &amp; <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">        zeroes += <span class="number">1</span></span><br><span class="line">        number = number &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> zeroes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">estimate_cardinality</span><span class="params">(values, k)</span>:</span></span><br><span class="line">    num_buckets = <span class="number">2</span> ** k</span><br><span class="line">    max_zeroes = [<span class="number">0</span>] * num_buckets</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">        h = hash(value)</span><br><span class="line">        bucket_index = h &amp; (num_buckets - <span class="number">1</span>)</span><br><span class="line">        bucket_hash = h &gt;&gt; k</span><br><span class="line">        num_zeros = trailing_zeroes(bucket_hash)</span><br><span class="line">        max_zeroes[bucket_index] = max(max_zeroes[bucket_index], num_zeros)</span><br><span class="line">    average_max_zeros = float(sum(max_zeroes)) / num_buckets</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> ** average_max_zeros) * num_buckets</span><br></pre></td></tr></table></figure>
<p>Parametr <code>k</code> určuje, kolik bitů se bude brát jako index skupiny. Tento parametr určuje přesnost algoritmu – čím vyšší <code>k</code>, tím větší přesnost. V proměnné <code>bucket_index</code> je uchováno číslo skupiny. Jak funguje ta magie na pravé straně rovnítka? </p>
<p>V proměnné <code>num_buckets</code> je počet skupin, což je vždy mocnina čísla dva. Pokud například <code>k = 3</code>, pak <code>num_buckets=8</code>. Číslo 8 má ve dvojkové soustavě podobu 1000. Odečteme-li jedničku, dostaneme číslo 7, které má podobu 0111. Po odečtení jedničky od <code>num_buckets</code> vždy dostaneme číslo, které má na konci <code>k</code> jedniček a předtím samé nuly. Dále provedeme logický součin (to je ten operátor <code>&amp;</code>). Pro vektor <code>1110110010100101</code> by tato operace vypadala takto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  1110110010100101&#10;&#38; 0000000000000111&#10;------------------&#10;  0000000000000101</span><br></pre></td></tr></table></figure>
<p>Účelem celé té magie je, abychom získali číslo, které na začátku obsahuje samé nuly a posledních <code>k</code> bitů má stejných jako daný hash <code>h</code>. </p>
<p>Dále spočítáme <code>bucket_hash</code>, což je původní hash, ze kterého odstraníme posledních <code>k</code> bitů tak, že celý hash posuneme o <code>k</code> bitů doprava. Posun se chová tak, že zkrátka všechny bity v čísle posune o <code>k</code> bitů doprava a zleva se číslo doplní nulami. (Bitový posun doprava o jedna se chová stejně, jako byste číslo vydělili dvěma a zahodili zbytek.) Z vektoru <code>1110110010100101</code> bychom po posunu o tři dostali <code>0001110110010100</code>. Tento vektor by byl uložen v proměnné <code>bucket_hash</code>. </p>
<p>Dále spočítáme počet nul na konci tohoto vektoru a pokud je tato hodnota větší než současná maximální hodnota uložená v poli <code>max_zeroes</code> na indexu <code>bucket_index</code>, přepíšeme hodnotu. </p>
<p>Na konci už jen spočítáme průměrný počet nul ve všech skupinách a spočítáme, jaký je průměrný počet unikátních prvků v každé skupině (<code>2 ** average_max_zeros</code>). Protože máme celkem <code>num_buckets</code> skupin, vynásobíme tuto hodnotu právě počtem skupin, čímž získáme finální odhad počtu unikátních prvků. Uf, a ani to nebolelo. Výsledky pro několik sad dat, které obsahují 250 000 unikátů a <code>k=10</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">331774.56203&#10;323349.39265&#10;307343.444439&#10;309430.914045&#10;294512.379123</span><br></pre></td></tr></table></figure>
<p>Néééé, pořád špatně :-(. Ale už jsme celkem blízko, nebojte. Všimněte si, že všechny výsledky jsou větší než správný výsledek. V průběhu algoritmus se totiž nahromadí různé chyby a odhad je proto znatelně větší než správný výsledek. Nicméně tyto chyby jsou poměrně stálé a lze odhadnout, jak velká chyba nastala. Když odhad vynásobíme hausnumerem 0.79402, získáme výsledky, které jsou zásadně lepší:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">263435.63774306054&#10;256745.88475195298&#10;244036.84175345476&#10;245694.33437001088&#10;233848.71927124445</span><br></pre></td></tr></table></figure>
<p>Zkusil jsem ještě multimnožinu, která má kardinalitu milion, výsledky:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V&#253;sledek              Chyba&#10;1017297.17411         1.01729717411&#10;1022820.99717         1.02282099717&#10;984108.725487         0.984108725487&#10;1018675.32683         1.01867532683&#10;1007020.2853          1.0070202853</span><br></pre></td></tr></table></figure>
<p>Hezky pěkně! Chyba se pohybuje pod 2 %, což je slušný výkon. A to je, dámy a pánové, algoritmus <strong>LogLog</strong>. Finální implementace i s hausnumerem vypadá takto:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trailing_zeroes</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    zeroes = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (number &amp; <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">        zeroes += <span class="number">1</span></span><br><span class="line">        number = number &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> zeroes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">estimate_cardinality</span><span class="params">(values, k)</span>:</span></span><br><span class="line">    num_buckets = <span class="number">2</span> ** k</span><br><span class="line">    max_zeroes = [<span class="number">0</span>] * num_buckets</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">        h = hash(value)</span><br><span class="line">        bucket_index = h &amp; (num_buckets - <span class="number">1</span>)</span><br><span class="line">        bucket_hash = h &gt;&gt; k</span><br><span class="line">        num_zeros = trailing_zeroes(bucket_hash)</span><br><span class="line">        max_zeroes[bucket_index] = max(max_zeroes[bucket_index], num_zeros)</span><br><span class="line">    average_max_zeros = float(sum(max_zeroes)) / num_buckets</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> ** average_max_zeros) * num_buckets * <span class="number">0.79402</span></span><br></pre></td></tr></table></figure>
<p>Jak upravit tento algoritmus abychom získali onen bájný a nejvíc nejlepší HyperLogLog si povíme příště. Prozatím se podíváme na to, jak je algoritmus paměťově náročný. </p>
<h2 id="Paměťová_náročnost">Paměťová náročnost</h2><p>Algoritmus je velice efektivní co do zabrané paměti. Jediné, co si musíme pamatovat, je pole udržující maxima. Délka tohoto pole je ovlivněna hodnotou <code>k</code>, tj. počtem bitů z vektoru, které bereme jako index skupiny. Pro dané <code>k</code> máme celkem <code>2<sup>k</sup></code> různých skupin a pole maxim má proto délku <code>2<sup>k</sup></code>. Tuto hodnotu jsme v implementaci nazývali <code>num_buckets</code>. </p>
<p>Jak velká musí být jedna buňka pole? Budeme do ní ukládat délky nulových suffixů. Můžu vám dopředu prozradit, že 64bitová hash stačí nejspíš pro všechny myslitelné multimnožiny světa, takže do tohoto pole musíme být schopni uložit čísla od 0 (vektor rovný samým jedničkám) do 64 (vektor rovný samým nulám). Dále, pokud budeme předpokládat, že <code>k</code> bude vždy větší než nula, pak platí, že nám stačí ukládat čísla od 0 do 63. Na to nám, prosím pěkně, stačí 6 bitů, protože <code>2<sup>6</sup> = 64</code>.</p>
<p>Ano, stačí nám “pole”, ve kterém má jedna buňka velikost 6 bitů. Dále vám můžu prozradit, že hodnota <code>k=10</code> stačí na to, abychom celkem slušně odhadli kardinalitu do řádů stovek milionů. Takto nastavený algoritmus by vytvořil pole o velikosti <code>2<sup>10</sup> = 1024</code>, ve kterém každá buňka zabírá 6 bitů. Celkem by toto pole zabíralo 6144 bitů, což je 768 bajtů. Ani ne kilobajt. </p>
<p>A to je všechno. </p>
<p>Nic jiného ukládat nepotřebujeme, vypočítané hashe můžeme zase hned zahazovat, stačí nám znát počet nul na konci vektoru. </p>
<p>Všimněte si, že pokud byste použili větší hashovací funkci, která by například vracela 128 bitů, paměťová náročnost by se moc nezměnila. Potřebovali bychom totiž uložit čísla od 0 do 127, na což nám stačí 7 bitů. Paměťovou náročnost tak především určuje parametr <code>k</code>, tj. počet skupin. </p>
<p>LogLog se hodí především tam, kde potřebujeme počítat multimnožiny o opravdu velké kardinalitě. Jak bylo vidět i na jednoduché ukázce nahoře, LogLog si ne úplně ideálně poradí s multimnožinami, které mají malou kardinalitu. Tomu lze nicméně také pomoci například tím, že pokud zjistíme, že multimnožina má nízkou kardinalitu, použijeme k odhadu jiný algoritmus, například již dříve popsaný <a href="/linear-counting/">Linear Counting</a>. I o tom bude řeč příště. </p>
<p>Zdroje:</p>
<ul>
<li><a href="http://algo.inria.fr/flajolet/Publications/DuFl03-LNCS.pdf" target="_blank" rel="external">Loglog Counting of Large Cardinalities [PDF]</a></li>
<li><a href="http://blog.notdot.net/2012/09/Dam-Cool-Algorithms-Cardinality-Estimation" target="_blank" rel="external">Damn Cool Algorithms: Cardinality Estimation</a> (odtud je více méně vykraden kód LogLogu)</li>
</ul>
<div class="relatedBox"><div class="relatedArticlesBox"><h2 id="relatedArticles">Související články:</h2><ol><li><a href="/linear-counting/">Linear Counting: Jak odhadnout počet unikátních hodnot</a></li><li><a href="/min-value/">Min Value: Jak odhadnout počet unikátních hodnot</a></li><li><a href="/hyperloglog/">HyperLogLog: Jak odhadnout počet unikátních hodnot</a></li><li><a href="/sjednoceni-hyperloglogu/">Sjednocení Hyperloglogu</a></li></ol></div></div><div class="articleTags"><strong><a href="/tags/algoritmy">#algoritmy</a></strong>, <strong><a href="/tags/hyperloglog">#hyperloglog</a></strong></div></div></article><div style="text-align: right"><div class="fb-like" data-layout="button_count" data-action="like" data-show-faces="true" data-share="true" style="margin-top: 10px; height: 30px"></div></div><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/algoritmy/" class="post__tag__link">algoritmy</a></li><li class="post__tag__item"><a href="/tags/hyperloglog/" class="post__tag__link">hyperloglog</a></li></ul><a href="/loglog/#disqus_thread" class="post__foot-link u-fr">Komentáře</a></footer></main><footer class="foot"><div class="foot-copy u-fl"><a href="/">Programio</a> píše <a href="http://www.havrlant.cz/">Lukáš Havrlant</a></div><menu class="page-menu u-fr"><li class="page-menu__item"><a title="Previous" href="/hyperloglog/" class="page-menu__link icon-arrow-left"></a></li><li class="page-menu__item"><a title="Next" href="/min-value/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],
j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})
(document,"script","programio","embed");
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-1559810-13');ga('send','pageview');
</script><div id="fb-root"></div><script>(function(d, s, id) {
var js, fjs = d.getElementsByTagName(s)[0];
if (d.getElementById(id)) return;
js = d.createElement(s); js.id = id;
js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&appId=166268190106534&version=v2.0";
fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script></body></html>