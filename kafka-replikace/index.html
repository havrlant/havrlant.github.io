<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="Programio" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><title>Jak funguje replikace v Kafce - Programio</title><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro"><link rel="stylesheet" href="/css/main.css" type="text/css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"> <a href="/">Programio</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Domů</a></li><li class="head-nav__item"><a href="/archives" class="head-nav__link">Archiv</a></li><li class="head-nav__item"><a href="http://www.havrlant.cz/" class="head-nav__link">O autorovi</a></li><li class="head-nav__item"><a href="/rss.xml" class="head-nav__link">RSS</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2015-03-30T18:31:02.000Z" class="post__time">30. 3. 2015</time><h1 class="post__title"><a href="/kafka-replikace/">Jak funguje replikace v Kafce</a></h1></header><div class="post__main echo"><p>Co se stane, když nám server s Kafka Brokerem shoří? Není Kafka Broker single point of failure? Asi všichni tušíme, že není… Pro každý topic totiž lze nastavit počet replikací. Pokud pro topic nastavíme replikaci na hodnotu tři, znamená to, že všechny zprávy, které do topicu pošleme, se zkopírují na další dva servery (respektive Kafka brokery) a jedna zpráva se bude celkem nacházet na třech serverech.</p>
<p>Důležité je, že se o replikaci nemusí starat producer – ten stále odesílá zprávy na <em>jeden</em> server a Kafka cluster už si sám řeší replikaci dat na další servery. Flow vypadá takto:</p>
<p><img src="/images/kafka/kafkamutliplebrokersbasic.svg" alt=""></p>
<p>Producer pošle zprávu brokerovi #1, ten zprávu zapíše k sobě na disk a zároveň se zpráva replikuje u brokerů #2 a #3, které si ji také zapíší na disk. Tím dojde k záloze a pokud Broker #1 vypadne, provoz se automaticky přesměruje na jeden ze zbývajících brokerů:</p>
<p><img src="/images/kafka/kafkamutliplebrokerschanged.svg" alt=""></p>
<p>Replikací nicméně nezvýšíme propustnost služby. Máme-li nastavenou replikaci 3, neznamená to, že když budeme číst zprávy z tohoto topicu, že budeme číst zprávy paralelně ze všech tří brokerů. Vždy se zvolí jeden broker jako leader, z něj se čtou zprávy a zbylé dva servery se pro čtení nepoužijí. V předchozím obrázku například consumer čte zprávy z brokeru #2 a z brokeru #3 žádné zprávy nedostává, přestože tento broker má zprávy z daného topicu uložené u sebe na disku.</p>
<h2 id="ISR">ISR</h2><p>Teď trochu detailněji o tom, jak replikce funguje. Tímto příkazem založíme topic:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper zookeeper01:<span class="number">2181</span> \</span><br><span class="line">  --replication-factor <span class="number">3</span> --partitions <span class="number">2</span> --topic bidrequests</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">Kafka musí založit dvě partitions, pro každou partition musí vybrat celkem tři brokery, které budou tyto partitiony obsluhovat a replikovat. Dejme tomu, že pro partitionu <span class="number">0</span> zvolí brokery kafka00, kafka01 a kafka02 a pro partition <span class="number">1</span> kafka03, kafka04 a kafka05. V každé skupině se zvolí leader pro danou partition. Leaderem se tak mohou stát například stroje kafka01 a kafka05. Ostatní Kafky slouží v tuto chvíli jako repliky. </span><br><span class="line"></span><br><span class="line">Kafka dále definuje pojem *<span class="keyword">in</span> sync replica*, což je broker, který je <span class="string">"živý"</span> (= udržuje svou session se ZooKeeperem) a který stíhá dostatečně rychle replikovat zprávy z leaderu (= offset poslední replikované zprávy je maximálně o x zpráv pozadu oproti leaderovi). </span><br><span class="line"></span><br><span class="line">Kafka si neustále udržuje informace o tom, které repliky jsou <span class="string">"aktuální"</span>. Může se totiž stát, že replikace spadne nebo že replikace přestane stíhat stahovat a ukládat data. Ty servery, které to stíhají, jsou nazývány *<span class="keyword">in</span> sync replica*, zkráceně ISR. Kafka si pak pro každou partitionu udržuje v ZooKeeperu množinu ISR, můžete se na ně podívat v ZooKeeper konzoli (`bin/zkCli.sh`):</span><br><span class="line"></span><br><span class="line">```plain</span><br><span class="line">$ get /brokers/topics/bidrequests/partitions/<span class="number">0</span>/state</span><br><span class="line">&#123;<span class="string">"leader"</span>:<span class="number">1</span>, <span class="string">"version"</span>:<span class="number">1</span>, <span class="string">"isr"</span>:[<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]&#125;</span><br><span class="line"></span><br><span class="line">$ get /brokers/topics/bidrequests/partitions/<span class="number">0</span>/state</span><br><span class="line">&#123;<span class="string">"leader"</span>:<span class="number">5</span>, <span class="string">"version"</span>:<span class="number">1</span>, <span class="string">"isr"</span>:[<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">Záznam v ZooKeeperu říká, že leaderem partitiony <span class="number">0</span> topicu *bidrequests* je kafka01 a synchronizované repliky jsou kafka02, kafka01 a kafka00 (i samotný leader je ISR). Tyto repliky pravidelně stahují nové zprávy z leadera a replikují je k sobě. Leader poskytne zprávu ke konzumaci pouze ve chvíli, kdy všechny ISR potvrdí, že zprávu přijaly.</span><br><span class="line"></span><br><span class="line">Pokud ISR spadne nebo pokud nestíhá stahovat nové zprávy z leadera, je tento uzel odstraněn z množiny ISR v ZooKeeperu a pokračuje se dále. Dejme tomu, že by kafka00 kompletně spadla:</span><br><span class="line"></span><br><span class="line">```plain</span><br><span class="line">$ get /brokers/topics/bidrequests/partitions/<span class="number">0</span>/state</span><br><span class="line">&#123;<span class="string">"leader"</span>:<span class="number">1</span>, <span class="string">"version"</span>:<span class="number">1</span>, <span class="string">"isr"</span>:[<span class="number">2</span>,<span class="number">1</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>Leader by od této chvíle čekal na potvrzení jen od kafka02. Pokud by spadnul leader, stala by se leaderem kafka02: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ get /brokers/topics/bidrequests/partitions/0/state&#10;&#123;&#34;leader&#34;:2, &#34;version&#34;:1, &#34;isr&#34;:[2]&#125;</span><br></pre></td></tr></table></figure>
<p>Všechny zprávy by v tuto chvíli tekly jen přes kafka02 a docházelo by k nulové záloze. Je přitom jedno, že vedle máme stroje kafka03, kafka04 a kafka05, které žijí – partition 0 má nastaveno, že poběží na strojích kafka00, kafka01 a kafka02, takže dokud tyto stroje neoživíme, nebude docházet k žádné replikaci. Nemusí to být samozřejmě <em>stejné</em> servery, stačí spustit Kafka broker se stejným ID.   </p>
<p>Pokud jakýmkoliv způsobem přivedeme k životu kafka01, ta zjistí, že by měla obsluhovat partition 0 topicu bidrequests, takže si začne z leaderu tahat chybějící data. Až je natáhne, stane se zase ISR, což se uloží do ZooKeeperu. Leader se nezmění.</p>
<pre><code class="plain">$ get /brokers/topics/bidrequests/partitions/0/state&#10;{&#34;leader&#34;:2, &#34;version&#34;:1, &#34;isr&#34;:[2,1]}
</code></pre>
<p>Máme-li nastavenou replikaci <code>r</code>, náš systém bude tolerovat až <code>r-1</code> nedostupných ISR. Pokud vypadne všech <code>r</code> strojů, máme samozřejmě smůlu. </p>
<h2 id="Nastavení_Kafky_týkající_se_replikace">Nastavení Kafky týkající se replikace</h2><p>Kafka umožňuje více specifikovat, jak se v určitých situacích týkajících se replikace chovat:</p>
<ul>
<li><code>request.required.acks</code> určuje, jestli bude producer čekat na potvrzení doručení zprávy. Možné hodnoty:<ul>
<li><code>0</code>: Producer nečeká na žádné potvrzení, rychlost odesílání je nejvyšší.</li>
<li><code>1</code>: Producer čeká na potvrzení leadera. </li>
<li><code>-1</code>: Producer čeká na potvrzení leadera a všech replik v ISR. Při tomto nastavení bue producer nejpomalejší, protože bude relativně dlouho čekat na potvrzení doručení zpráv, ale zase máte největší jistotu, že o žádnou zprávu nepřijdete. </li>
</ul>
</li>
<li><code>min.insync.replicas</code> určuje minimální počet ISR. Pokud například nastavíte <code>request.required.acks</code> na <code>-1</code>, tj. producer bude čekat na potvrzení od všech ISR, může se stejně stát, že všechny replicy spadnou a ISR bude obsahovat pouze leadera. Tímto nastavením můžete říci, že pokud je velikost ISR menší než <code>min.insync.replicas</code>, začne producer vyhazovat při odesílání výjimky. </li>
</ul>
<div class="relatedBox"><div class="relatedArticlesBox"><h2 id="relatedArticles">Související články:</h2><ol><li><a href="/lambda-architecture/">Jak zpracováváme velké množství dat: Lambda Architecture</a></li><li><a href="/kafka/">Kafka messaging system</a></li><li><a href="/kafka-consumer/">Jak funguje Kafka consumer</a></li><li><a href="/samza/">Samza: distributed stream processing framework</a></li><li><a href="/samza-windowing/">Windowing v Samze</a></li><li><a href="/samza-local-state/">Uložení lokálního stavu v Samze</a></li><li><a href="/druid-io/">Druid.io: distribuovaná immutable databáze pro analytické výpočty</a></li><li><a href="/druid-io-architektura/">Architektura Druid.io</a></li><li><a href="/druid-io-ingest/">Jak Druid.io agreguje data</a></li></ol></div></div><div class="articleTags"><strong><a href="/tags/bigdata">#bigdata</a></strong>, <strong><a href="/tags/kafka">#kafka</a></strong></div></div></article><div style="text-align: right"><div class="fb-like" data-layout="button_count" data-action="like" data-show-faces="true" data-share="true" style="margin-top: 10px; height: 30px"></div></div><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/bigdata/" class="post__tag__link">bigdata</a></li><li class="post__tag__item"><a href="/tags/kafka/" class="post__tag__link">kafka</a></li></ul><a href="/kafka-replikace/#disqus_thread" class="post__foot-link u-fr">Komentáře</a></footer></main><footer class="foot"><div class="foot-copy u-fl"><a href="/">Programio</a> píše <a href="http://www.havrlant.cz/">Lukáš Havrlant</a></div><menu class="page-menu u-fr"><li class="page-menu__item"><a title="Previous" href="/samza/" class="page-menu__link icon-arrow-left"></a></li><li class="page-menu__item"><a title="Next" href="/kafka-consumer/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],
j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})
(document,"script","programio","embed");
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-1559810-13');ga('send','pageview');
</script><div id="fb-root"></div><script>(function(d, s, id) {
var js, fjs = d.getElementsByTagName(s)[0];
if (d.getElementById(id)) return;
js = d.createElement(s); js.id = id;
js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&appId=166268190106534&version=v2.0";
fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script></body></html>