<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="Programio" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><title>Min Value: Jak odhadnout počet unikátních hodnot - Programio</title><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro"><link rel="stylesheet" href="/css/main.css" type="text/css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"> <a href="/">Programio</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Domů</a></li><li class="head-nav__item"><a href="/archives" class="head-nav__link">Archiv</a></li><li class="head-nav__item"><a href="http://www.havrlant.cz/" class="head-nav__link">O autorovi</a></li><li class="head-nav__item"><a href="/rss.xml" class="head-nav__link">RSS</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2014-10-21T17:15:19.000Z" class="post__time">21. 10. 2014</time><h1 class="post__title"><a href="/min-value/">Min Value: Jak odhadnout počet unikátních hodnot</a></h1></header><div class="post__main echo"><p>V <a href="/linear-counting/">minulém článku o Linear Countingu</a> jsme si probrali základní algoritmy na výpočet a odhad počtu unikátních hodnot v nějaké sadě dat. Dnes náš čeká další pravděpodobností algoritmus, který umožňuje se slušnou přesností a malými paměťovými nároky odhadnout počet unikátů. </p>
<h2 id="Min_Value">Min Value</h2><p>V článku budeme pracovat pouze s reálnými čísly z jednotkového intervalu <code>(0; 1)</code>. Představme si množinu čísel z tohoto intervalu, která je rovnoměrně rozložena, např. množina čísel <code>{0,25; 0,5; 0,75}</code>. Sousední čísla jsou vždy od sebe (a od nuly a od jedničky) vzdálena právě o 0,25. Jak nám to pomůže spočítat počet unikátních prvků? </p>
<p>Když vám řeknu, že máme takovou rovnoměrně rozloženou množinu čísel z jednotkového intervalu, a tato čísla mají mezi sebou vzdálenost právě 0,2 – vypočítáte, kolik prvků taková množina má? Samozřejmě, jedná se o množinu <code>{0,2; 0,4; 0,6; 0,8}</code>, jejíž kardinalita je rovna čtyřem. Máme-li na vstupu rovnoměrně rozložená čísla z jednotkového intervalu a známe-li vzdálenost sousedních čísel, jsme schopni snadno vypočítat počet prvků.</p>
<p>Přitom vzdálenost mezi sousedními čísly je rovna minimálnímu prvku množiny – vzdálenost sousedních prvků množiny <code>{0,25; 0,5; 0,75}</code> je 0,25 atp. Při vypočítávání počtu prvků rovnoměrně rozložených čísel nám stačí nějak zjistit minimální prvek. Pak můžeme vypočítat počet prvků <code>p</code> jednoduchým vzorcem:</p>
<p><img src="/images/minvzorec.svg" alt=""></p>
<p>kde <code>m</code> je onen minimální prvek. </p>
<h2 id="A_zase_budeme_hashovat…">A zase budeme hashovat…</h2><p>No jo, jenže jak toto využít, pokud máme na vstupu nějaké řetězce nebo jiné hodnoty, které zrovna nesplňují podmínku rovnoměrného rozložení do jednotkového intervalu? Pomůže si opět <a href="http://en.wikipedia.org/wiki/MurmurHash" target="_blank" rel="external">starou dobrou hashovací funkcí</a>, která nám může pro libovolný vstup vrátit racionální číslo z jednotkového intervalu. Sestrojit takovou hashovací funkci bude snadné. </p>
<p>Tím bychom dostali z dat racionální čísla, ale jak zařídit, aby tato čísla byla rovnoměrně rozložená? To už sice nepůjde, ale můžeme si pomoci jinak. Hashovací funkce se totiž z našeho pohledu chová poměrně “náhodně”. Pro velmi podobná slova jako “ahoj”, “ahok” a “ahol” nám bude hashovací funkce nejspíš vracet velmi odlišné checksumy. Jinými slovy: pokud zahashujeme tisíc různých hodnot do jednotkového intervalu, je velice nepravděpodobné, aby výrazná většina čísel byla například menší než jedna polovina. Naopak je velmi pravděpodobné, že tato čísla budou rozložena více méně pravidelně. Čím více dat zahashujeme, tím to rozložení bude pravidelnější. </p>
<p>Z této myšlenky dostáváme jednoduchý algoritmus: projdeme vstupní data, každý prvek zahashujeme do jednotkového intervalu a zapamatujeme si minimální prvek. Počet unikátních prvků odhadneme podle předchozího vzorce. Implementace v Pythonu:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from uuid import uuid4&#10;&#10;def nhash(item, n):&#10;    return hash(item) % (2 ** n)&#10;&#10;def unit_interval_hash(item, n):&#10;    integer_hash = nhash(item, n) + 1&#10;    return integer_hash / float(2 ** n)&#10;&#10;def count_unique_using_minimum(values, n):&#10;    numbers_from_unit_interval = (unit_interval_hash(item, n) for item in values)&#10;    minimum = min(numbers_from_unit_interval)&#10;    return int(1 / minimum) - 1&#10;&#10;for _ in xrange(10):&#10;    print count_unique_using_minimum((uuid4() for _ in xrange(10000)), 16)</span><br></pre></td></tr></table></figure>
<p>Funkce <code>unit_interval_hash</code> nám vrací desetinné číslo z intervalu <code>(0, 1&gt;</code>. Funkce <code>count_unique_using_minimum</code> nejprve převede všechny vstupní hodnoty právě na toto číslo, nalezne minimum a vrací <code>1 / minimum - 1</code>. Všimněte si, že vůbec nezáleží na tom, kolik je v sadě dat stejných hodnot – pro dvě stejné hodnoty nám hashovací funkce vrátí stejné racionální číslo, což nám nijak neovlivní výsledné minimum. Proto tímto algoritmem spočítáme počet <strong>unikátních</strong> prvků. </p>
<p>Jaké jsou výsledky? (Na každém řádku je odhadnutá kardinalita, správná kardinalita je přitom 10 000.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5957&#10;16384&#10;13107&#10;9362&#10;65536&#10;8192&#10;21845&#10;13107&#10;21845&#10;8192</span><br></pre></td></tr></table></figure>
<p>No, nic moc, že? Algoritmus projel deset různých sad idéček, ve kterých bylo vždy deset tisíc unikátních hodnot. Vypočtené odhady jsou tak většinou dost mimo. Pokud bychom je zprůměrovali, dostali bychom se k hodnotě 18 352. Pořád je dost mimo, na druhou stranu si vemte paměťové nároky – <strong>jsou konstantní</strong>! Na to, abyste nalezli minimum, vám stačí si v paměti vždy uchovávat jednu proměnnou, do které uložíte aktuální minimum a to je vše. Takže jo, odhad na prd, ale zase skoro nic nestojí. </p>
<h2 id="Vylepšujeme">Vylepšujeme</h2><p>Vidíme, že algoritmus je především nestabilní – jednou nám vrátí celkem dobrý odhad (9362), podruhé nám vrátí odhad, který je úplně mimo (65536). Jak z toho ven? Můžeme si pomoci tím, že rozdělíme vstupní data do několika částí a spočítáme počet unikátních prvků pro každou část a nakonec všechno hezky zprůměrujeme. Mohli bychom se rozhodnout podle prvního znaku v našem idéčku. Takže spočítáme zvlášť počet unikátů pro idéčka, která začínají na písmena “a”, pak pro ty, které začínají na písmeno “b” atp. Kód:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from uuid import uuid4&#10;&#10;def nhash(item, n):&#10;    return hash(item) % (2 ** n)&#10;&#10;def unit_interval_hash(item, n):&#10;    integer_hash = nhash(item, n) + 1&#10;    return integer_hash / float(2 ** n)&#10;&#10;def count_unique_using_minimum(values, n):&#10;    min_values = &#123;&#125;&#10;    for item in values:&#10;        first_char = str(item)[0]&#10;        hashed_value = unit_interval_hash(item, n)&#10;        min_values[first_char] = min(min_values.get(first_char, 1), hashed_value)&#10;    average_minimum = sum(min_values.values()) / len(min_values)&#10;    return (int(1 / average_minimum) - 1) * len(min_values)&#10;&#10;for _ in xrange(10):&#10;    print count_unique_using_minimum((uuid4() for _ in xrange(10000)), 16)</span><br></pre></td></tr></table></figure>
<p>Změny jsou ve funkci <code>count_unique_using_minimum</code>. V proměnné <code>min_values</code> si uchováváme minima pro každou skupinu. Na konci sečteme všechna minima a vydělíme je počtem všech uložených hodnot – získáme průměrné minimum. Výrazem <code>1/average_minimum</code> zjistíme, jaký je průměrný počet unikátních hodnot v každé skupině – tuto hodnotu tak ještě vynásobíme počtem skupin a získáme odhadnutý počet unikátních hodnot v předané sadě dat. A jak tento upravený postup funguje?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11312&#10;7504&#10;10560&#10;8160&#10;9344&#10;12688&#10;10976&#10;11616&#10;16240&#10;6832</span><br></pre></td></tr></table></figure>
<p>No, pořád to není dobré, ale je to určitě lepší. Algoritmus je stabilnější. Můžeme zkusit upravit funkci tak, aby se skupiny netvořily podle prvního znaku, ale například podle dvou prvních znaků idéčka, tj. takto:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first_char = str(item)[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># ToDo: choose better name for variable</span></span><br></pre></td></tr></table></figure>
<p>Výsledky by potom byly takovéto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9728&#10;9728&#10;9984&#10;10240&#10;8960&#10;10752&#10;9728&#10;9472&#10;11264&#10;9472</span><br></pre></td></tr></table></figure>
<p>Nooo to už není úplně špatné, ne? Pokud ještě zkusíme sto tisíc unikátních hodnot, první dva znaky a <code>n = 24</code>, dostaneme tyto výsledky:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">103936&#10;110080&#10;102656&#10;101120&#10;101376&#10;108288&#10;97536&#10;97024&#10;107776&#10;92416</span><br></pre></td></tr></table></figure>
<p>Docela to ujde. Ale stále existují lepší algoritmy, nebojte. </p>
<p>A jaká je paměťová náročnost? Musíme si uchovávat minimum pro každou skupinu, nic víc. Pokud máme idéčka v hex formátu, tak to znamená, že si musíme pamatovat maximálně 16<sup>x</sup> minim, kde <code>x</code> je počet znaků, ze kterých tvoříme klíč skupiny. Jedno minimum je jedno racionální číslo, tj. nějaký typ <code>double</code> nebo <code>float</code>. </p>
<p>Poznámka na konec: rozdělení vstupu do několika skupin jsme si mohli dovolit proto, že jsme na vstupu měli idéčka, která se chovala jako náhodný řetězec. Pokud bychom neměli na vstupu náhodný řetězec, ale nějaká data v určitém formátu, museli bychom rozdělení udělat jinak. Pokud by například každé idéčko začínalo prefixem <code>userid-</code>, tak by asi rozdělení do skupin podle prvního znaku moc nefungovalo, žeano. </p>
<p>Tenhle algoritmus jsem popsal spíš pro zajímavost, opravdový majstrštyk nás čeká příští týden. </p>
<!-- p="A jestli vás článek opravdu zaujal, "--><!--  a(href="http://www.ibillboard.com/cs/spolecnost/spolecnost/kariera/202-vyvojar-nodejs-javascript")="tak pojďte pracovat k nám do firmy!"--><!--  =" Podobných problémů řešíme mraky." -->
<div class="relatedBox"><div class="relatedArticlesBox"><h2 id="relatedArticles">Související články:</h2><ol><li><a href="/linear-counting/">Linear Counting: Jak odhadnout počet unikátních hodnot</a></li><li><a href="/loglog/">LogLog: Jak odhadnout počet unikátních hodnot</a></li><li><a href="/hyperloglog/">HyperLogLog: Jak odhadnout počet unikátních hodnot</a></li><li><a href="/sjednoceni-hyperloglogu/">Sjednocení Hyperloglogu</a></li></ol></div></div><div class="articleTags"><strong><a href="/tags/algoritmy">#algoritmy</a></strong>, <strong><a href="/tags/hyperloglog">#hyperloglog</a></strong></div></div></article><div style="text-align: right"><div class="fb-like" data-layout="button_count" data-action="like" data-show-faces="true" data-share="true" style="margin-top: 10px; height: 30px"></div></div><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/algoritmy/" class="post__tag__link">algoritmy</a></li><li class="post__tag__item"><a href="/tags/hyperloglog/" class="post__tag__link">hyperloglog</a></li></ul><a href="/min-value/#disqus_thread" class="post__foot-link u-fr">Komentáře</a></footer></main><footer class="foot"><div class="foot-copy u-fl"><a href="/">Programio</a> píše <a href="http://www.havrlant.cz/">Lukáš Havrlant</a></div><menu class="page-menu u-fr"><li class="page-menu__item"><a title="Previous" href="/loglog/" class="page-menu__link icon-arrow-left"></a></li><li class="page-menu__item"><a title="Next" href="/linear-counting/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],
j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})
(document,"script","programio","embed");
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-1559810-13');ga('send','pageview');
</script><div id="fb-root"></div><script>(function(d, s, id) {
var js, fjs = d.getElementsByTagName(s)[0];
if (d.getElementById(id)) return;
js = d.createElement(s); js.id = id;
js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&appId=166268190106534&version=v2.0";
fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script></body></html>